<?php

namespace Swac\JavaScript\Client;

use Swac\Command\App;
use Swac\Rest\Config;
use Swac\Rest\Operation;
use Swac\Rest\Parameter;
use Swac\Rest\Renderer;
use Swac\Rest\Response;
use Swaggest\CodeBuilder\AbstractTemplate;
use Swaggest\GoCodeBuilder\Templates\Code;
use Swaggest\JsonSchema\Schema;
use Swaggest\PhpCodeBuilder\JSDoc\TypeBuilder;
use Swaggest\PhpCodeBuilder\PhpCode;
use Swaggest\SwaggerHttp\StatusCodes;

class Client extends AbstractTemplate implements Renderer
{
    const PARAM_FIELD_NAME_META = 'jsDocFieldName';
    const RAW_CALLBACK = 'RawCallback';

    /**
     * @var TypeBuilder
     */
    public $jsDocTypes;

    /** @var string[] */
    private $operationNames;

    /** @var string */
    public $clientName = 'APIClient';

    /** @var string[] */
    private $responseCallbacks = [];

    /** @var Code */
    private $clientCode;

    public function __construct()
    {
        $ver = App::$ver;

        $this->jsDocTypes = new TypeBuilder();
        $this->jsDocTypes->trimNamePrefix[] = '#/components/schemas';

        $this->jsDocTypes->file .= <<<JS
// Code is generated by github.com/swaggest/swac $ver, do not edit. ðŸ¤–


JS;
        $this->clientCode = new Code();

        $this->clientCode->addSnippet(<<<JS
// Code is generated by github.com/swaggest/swac $ver, do not edit. ðŸ¤–

/**
 * @constructor
 * @param {string} baseURL - Base URL.
 */
function {$this->clientName}(baseURL) {
    // Trim trailing backslash.
    this.baseURL = (baseURL.charAt(baseURL.length - 1) === '/') ? baseURL.slice(0, -1) : baseURL;
}


JS
        );
    }

    public function setConfig(Config $config)
    {
        // TODO: Implement setConfig() method.
    }

    public function addOperation(Operation $operation)
    {
        $funcName = '';
        if ($operation->operationId !== null) {
            $funcName = $this->makeName($operation->operationId);
        }

        if (empty($funcName) || isset($this->operationNames)) {
            $funcName = $this->makeName($operation->method . '_' . $operation->path);
        }

        $this->operationNames[$funcName] = true;

        $this->makeOperationFunction($operation, $funcName);
    }

    /**
     * @param Parameter[] $parameters
     * @param string $pattern
     * @return string
     */
    private function makeURL($parameters, $pattern)
    {
        $res = "var url = this.baseURL + '$pattern?';\n";
        if (!empty($parameters)) {
            foreach ($parameters as $parameter) {
                $field = $parameter->meta[self::PARAM_FIELD_NAME_META];
                $encodedValue = "encodeURIComponent(req.$field)";
                if ($parameter->isJson) {
                    $encodedValue = "encodeURIComponent(JSON.stringify(req.$field))";
                }

                if ($parameter->in === Parameter::PATH) {
                    $res = str_replace("{{$parameter->name}}", "' + {$encodedValue} +\n'", $res);
                }

                if ($parameter->in === Parameter::QUERY) {
                    $res .= <<<JS
if (req.$field != null) {
    url += '{$field}=' + {$encodedValue} + '&'
}

JS;
                }
            }
        }

        $res .= "url = url.slice(0, -1)\n";

        return $res;
    }

    /**
     * @param Parameter[] $parameters
     * @return string
     */
    private function makeRequestHeaders($parameters) {
        if (empty($parameters)) {
            return '';
        }

        foreach ($parameters as $parameter) {
            if ($parameter->in === Parameter::HEADER) {
                $field = $parameter->meta[self::PARAM_FIELD_NAME_META];
                $res .= <<<JS
if (typeof req.$field !== 'undefined') {
    x.setRequestHeader('{$parameter->name}', req.$field);
}

JS;
            }
        }

        return $res;
    }

    /**
     * @param Parameter[] $parameters
     * @return string
     */
    private function makeRequestJSONBody($parameters)
    {
        if (empty($parameters)) {
            return '';
        }

        foreach ($parameters as $parameter) {
            if ($parameter->in === Parameter::BODY) {
                $field = $parameter->meta[self::PARAM_FIELD_NAME_META];
                return <<<JS
if (typeof req.$field !== 'undefined') {
    x.setRequestHeader("Content-Type", "application/json; charset=utf-8");
    x.send(JSON.stringify(req.$field))
    return
}

JS;
            }
        }

        return '';
    }

    /**
     * @param Parameter[] $parameters
     */
    private function makeRequestFormData($parameters)
    {
        if (empty($parameters)) {
            return '';
        }

        $res = '';

        foreach ($parameters as $parameter) {
            if ($parameter->in === Parameter::FORM_DATA) {
                $field = $parameter->meta[self::PARAM_FIELD_NAME_META];
                $res .= <<<JS
if (typeof req.$field !== 'undefined') {
    formData += '{$field}=' + encodeURIComponent(req.$field) + '&'
}

JS;
            }
        }

        if ($res != '') {
            $res = <<<JS
var formData = ''
$res
if (formData !== '') {
    x.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
    x.send(formData.slice(0, -1))
    return  
}

JS;
        }

        return $res;
    }

    /**
     * @param Operation $o
     * @param string $funcName
     */
    private function makeOperationFunction($o, $funcName)
    {
        $reqType = $this->makeRequestType($o->parameters, $funcName);
        $args = ['req'];

        $responseArguments = new Code();
        $responseSwitch = new Code();
        $hasDefault = false;
        foreach ($o->responses as $response) {
            $cbType = $this->makeResponseType($response);
            $responseArg = 'JSON.parse(x.responseText)';
            if ($cbType === self::RAW_CALLBACK) {
                $responseArg = 'x';
            }

            if ($response->isDefault) {
                $cbName = 'onDefault';
                $responseArguments->addSnippet(<<<JSDOC
 * @param {{$cbType}} {$cbName}

JSDOC
                );
                $args[] = $cbName;

                $responseSwitch->addSnippet(<<<CODE
            default:
                if (typeof({$cbName}) == 'function') {
                    {$cbName}($responseArg);
                }
                break;

CODE
                );

                $hasDefault = true;
                continue;
            }

            $status = StatusCodes::getInfoByCode($response->statusCode);
            $cbName = 'on' . $this->makeName($status->phrase, false);

            $responseArguments->addSnippet(<<<JSDOC
 * @param {{$cbType}} {$cbName}

JSDOC
            );

            $args[] = $cbName;
            $responseSwitch->addSnippet(<<<CODE
            case {$response->statusCode}:
                if (typeof({$cbName}) == 'function') {
                    {$cbName}($responseArg);
                }
                break;

CODE
            );
        }

        if (!$hasDefault) {
            $responseSwitch->addSnippet(<<<CODE
            default:
                throw {err: 'unexpected response', data: x}

CODE
            );
        }

        $args = join(', ', $args);
        $method = strtoupper($o->method);

        $code = <<<JS
/**
 * @param {{$reqType}} req
{$responseArguments} */
{$this->clientName}.prototype.{$funcName} = function ($args) {
    var x = new XMLHttpRequest();
    x.onreadystatechange = function () {
        if (x.readyState !== XMLHttpRequest.DONE) {
            return
        }
    
        switch (x.status) {
{$responseSwitch}        }
    };
    
    {$this->padLines('    ', $this->makeURL($o->parameters, $o->path))}
    x.open("{$method}", url, true);
    {$this->padLines('    ', $this->makeRequestJSONBody($o->parameters))}
    {$this->padLines('    ', $this->makeRequestFormData($o->parameters))}
    x.send();
}


JS;

        $this->clientCode->addSnippet($code);

    }


    /**
     * @param Response $response
     * @return string|null
     */
    private function makeResponseType($response)
    {
        if ($response->schema === null) {
            $type = '___raw';
            $cbType = self::RAW_CALLBACK;
            if (!isset($this->responseCallbacks[$type])) {
                $cb = <<<JSDOC
/**
 * @callback {$cbType}
 * @param {XMLHttpRequest} value
 */


JSDOC;
                $this->jsDocTypes->file .= $cb;
                $this->responseCallbacks[$type] = $cbType;
            }

            return $cbType;
        }

        $type = $this->jsDocTypes->getTypeString($response->schema);
        $cbType = $this->makeName($type . '_callback', false);
        if (!isset($this->responseCallbacks[$type])) {
            $cb = <<<JSDOC
/**
 * @callback {$cbType}
 * @param {{$type}} value
 */


JSDOC;
            $this->jsDocTypes->file .= $cb;
            $this->responseCallbacks[$type] = $cbType;
        }

        return $cbType;
    }

    /**
     * @param Parameter[] $parameters
     * @param string $funcName
     * @return string
     */
    private function makeRequestType($parameters, $funcName)
    {
        $reqSchema = new Schema();
        $reqSchema->type = Schema::OBJECT;
        $reqSchema->setFromRef($funcName . '/Request');

        $paramNames = [];

        if (!empty($parameters)) {
            foreach ($parameters as $parameter) {
                $name = $this->makeName($parameter->name);
                if (isset($paramNames[$name])) {
                    $name = $this->makeName($parameter->name . '_' . $parameter->in);
                }

                $paramNames[$name] = true;
                $parameter->meta[self::PARAM_FIELD_NAME_META] = $name;

                $reqSchema->setProperty($name, $parameter->schema);
            }
        }

        return $this->jsDocTypes->getTypeString($reqSchema);
    }

    private function makeName($s, $lowerFirst = true)
    {
        return PhpCode::makePhpName($s, $lowerFirst);
    }

    public function store($path)
    {
        file_put_contents($path . '/jsdoc.js', $this->jsDocTypes->file);
        file_put_contents($path . '/client.js', $this->clientCode->render());
    }

    protected function toString()
    {
    }
}