// Code generated by github.com/swaggest/swac <version>, DO NOT EDIT.

package uber

import (
	"bytes"
	"encoding/json"
	"errors"
)

// Product structure is generated from "#/definitions/Product".
type Product struct {
	ID                   string                 `json:"product_id,omitempty"`   // Unique identifier representing a specific product for a given latitude & longitude. For example, uberX in San Francisco will have a different product_id than uberX in Los Angeles.
	Description          string                 `json:"description,omitempty"`  // Description of product.
	DisplayName          string                 `json:"display_name,omitempty"` // Display name of product.
	Capacity             string                 `json:"capacity,omitempty"`     // Capacity of product. For example, 4 people.
	Image                string                 `json:"image,omitempty"`        // Image URL representing the product.
	AdditionalProperties map[string]interface{} `json:"-"`                      // All unmatched properties.
}

type marshalProduct Product

var knownKeysProduct = []string{
	"product_id",
	"description",
	"display_name",
	"capacity",
	"image",
}

// UnmarshalJSON decodes JSON.
func (p *Product) UnmarshalJSON(data []byte) error {
	var err error

	mp := marshalProduct(*p)

	err = json.Unmarshal(data, &mp)
	if err != nil {
		return err
	}

	var rawMap map[string]json.RawMessage

	err = json.Unmarshal(data, &rawMap)
	if err != nil {
		rawMap = nil
	}

	for _, key := range knownKeysProduct {
		delete(rawMap, key)
	}

	for key, rawValue := range rawMap {
		if mp.AdditionalProperties == nil {
			mp.AdditionalProperties = make(map[string]interface{}, 1)
		}

		var val interface{}

		err = json.Unmarshal(rawValue, &val)
		if err != nil {
			return err
		}

		mp.AdditionalProperties[key] = val
	}

	*p = Product(mp)

	return nil
}

// MarshalJSON encodes JSON.
func (p Product) MarshalJSON() ([]byte, error) {
	if len(p.AdditionalProperties) == 0 {
		return json.Marshal(marshalProduct(p))
	}

	return marshalUnion(marshalProduct(p), p.AdditionalProperties)
}

// Error structure is generated from "#/definitions/Error".
type Error struct {
	Code                 int64                  `json:"code,omitempty"`    // Format: int32.
	Message              string                 `json:"message,omitempty"`
	Fields               string                 `json:"fields,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`                 // All unmatched properties.
}

type marshalError Error

var knownKeysError = []string{
	"code",
	"message",
	"fields",
}

// UnmarshalJSON decodes JSON.
func (e *Error) UnmarshalJSON(data []byte) error {
	var err error

	me := marshalError(*e)

	err = json.Unmarshal(data, &me)
	if err != nil {
		return err
	}

	var rawMap map[string]json.RawMessage

	err = json.Unmarshal(data, &rawMap)
	if err != nil {
		rawMap = nil
	}

	for _, key := range knownKeysError {
		delete(rawMap, key)
	}

	for key, rawValue := range rawMap {
		if me.AdditionalProperties == nil {
			me.AdditionalProperties = make(map[string]interface{}, 1)
		}

		var val interface{}

		err = json.Unmarshal(rawValue, &val)
		if err != nil {
			return err
		}

		me.AdditionalProperties[key] = val
	}

	*e = Error(me)

	return nil
}

// MarshalJSON encodes JSON.
func (e Error) MarshalJSON() ([]byte, error) {
	if len(e.AdditionalProperties) == 0 {
		return json.Marshal(marshalError(e))
	}

	return marshalUnion(marshalError(e), e.AdditionalProperties)
}

// PriceEstimate structure is generated from "#/definitions/PriceEstimate".
type PriceEstimate struct {
	ProductID            string                 `json:"product_id,omitempty"`       // Unique identifier representing a specific product for a given latitude & longitude. For example, uberX in San Francisco will have a different product_id than uberX in Los Angeles.
	CurrencyCode         string                 `json:"currency_code,omitempty"`    // [ISO 4217](http://en.wikipedia.org/wiki/ISO_4217) currency code.
	DisplayName          string                 `json:"display_name,omitempty"`     // Display name of product.
	Estimate             string                 `json:"estimate,omitempty"`         // Formatted string of estimate in local currency of the start location. Estimate could be a range, a single number (flat rate) or "Metered" for TAXI.
	LowEstimate          float64                `json:"low_estimate,omitempty"`     // Lower bound of the estimated price.
	HighEstimate         float64                `json:"high_estimate,omitempty"`    // Upper bound of the estimated price.
	SurgeMultiplier      float64                `json:"surge_multiplier,omitempty"` // Expected surge multiplier. Surge is active if surge_multiplier is greater than 1. Price estimate already factors in the surge multiplier.
	AdditionalProperties map[string]interface{} `json:"-"`                          // All unmatched properties.
}

type marshalPriceEstimate PriceEstimate

var knownKeysPriceEstimate = []string{
	"product_id",
	"currency_code",
	"display_name",
	"estimate",
	"low_estimate",
	"high_estimate",
	"surge_multiplier",
}

// UnmarshalJSON decodes JSON.
func (p *PriceEstimate) UnmarshalJSON(data []byte) error {
	var err error

	mp := marshalPriceEstimate(*p)

	err = json.Unmarshal(data, &mp)
	if err != nil {
		return err
	}

	var rawMap map[string]json.RawMessage

	err = json.Unmarshal(data, &rawMap)
	if err != nil {
		rawMap = nil
	}

	for _, key := range knownKeysPriceEstimate {
		delete(rawMap, key)
	}

	for key, rawValue := range rawMap {
		if mp.AdditionalProperties == nil {
			mp.AdditionalProperties = make(map[string]interface{}, 1)
		}

		var val interface{}

		err = json.Unmarshal(rawValue, &val)
		if err != nil {
			return err
		}

		mp.AdditionalProperties[key] = val
	}

	*p = PriceEstimate(mp)

	return nil
}

// MarshalJSON encodes JSON.
func (p PriceEstimate) MarshalJSON() ([]byte, error) {
	if len(p.AdditionalProperties) == 0 {
		return json.Marshal(marshalPriceEstimate(p))
	}

	return marshalUnion(marshalPriceEstimate(p), p.AdditionalProperties)
}

// Profile structure is generated from "#/definitions/Profile".
type Profile struct {
	FirstName            string                 `json:"first_name,omitempty"` // First name of the Uber user.
	LastName             string                 `json:"last_name,omitempty"`  // Last name of the Uber user.
	Email                string                 `json:"email,omitempty"`      // Email address of the Uber user.
	Picture              string                 `json:"picture,omitempty"`    // Image URL of the Uber user.
	PromoCode            string                 `json:"promo_code,omitempty"` // Promo code of the Uber user.
	AdditionalProperties map[string]interface{} `json:"-"`                    // All unmatched properties.
}

type marshalProfile Profile

var knownKeysProfile = []string{
	"first_name",
	"last_name",
	"email",
	"picture",
	"promo_code",
}

// UnmarshalJSON decodes JSON.
func (p *Profile) UnmarshalJSON(data []byte) error {
	var err error

	mp := marshalProfile(*p)

	err = json.Unmarshal(data, &mp)
	if err != nil {
		return err
	}

	var rawMap map[string]json.RawMessage

	err = json.Unmarshal(data, &rawMap)
	if err != nil {
		rawMap = nil
	}

	for _, key := range knownKeysProfile {
		delete(rawMap, key)
	}

	for key, rawValue := range rawMap {
		if mp.AdditionalProperties == nil {
			mp.AdditionalProperties = make(map[string]interface{}, 1)
		}

		var val interface{}

		err = json.Unmarshal(rawValue, &val)
		if err != nil {
			return err
		}

		mp.AdditionalProperties[key] = val
	}

	*p = Profile(mp)

	return nil
}

// MarshalJSON encodes JSON.
func (p Profile) MarshalJSON() ([]byte, error) {
	if len(p.AdditionalProperties) == 0 {
		return json.Marshal(marshalProfile(p))
	}

	return marshalUnion(marshalProfile(p), p.AdditionalProperties)
}

// Activities structure is generated from "#/definitions/Activities".
type Activities struct {
	// Position in pagination.
	// Format: int32.
	Offset               int64                  `json:"offset,omitempty"`
	// Number of items to retrieve (100 max).
	// Format: int32.
	Limit                int64                  `json:"limit,omitempty"`
	// Total number of items available.
	// Format: int32.
	Count                int64                  `json:"count,omitempty"`
	History              []Activity             `json:"history,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`                 // All unmatched properties.
}

type marshalActivities Activities

var knownKeysActivities = []string{
	"offset",
	"limit",
	"count",
	"history",
}

// UnmarshalJSON decodes JSON.
func (a *Activities) UnmarshalJSON(data []byte) error {
	var err error

	ma := marshalActivities(*a)

	err = json.Unmarshal(data, &ma)
	if err != nil {
		return err
	}

	var rawMap map[string]json.RawMessage

	err = json.Unmarshal(data, &rawMap)
	if err != nil {
		rawMap = nil
	}

	for _, key := range knownKeysActivities {
		delete(rawMap, key)
	}

	for key, rawValue := range rawMap {
		if ma.AdditionalProperties == nil {
			ma.AdditionalProperties = make(map[string]interface{}, 1)
		}

		var val interface{}

		err = json.Unmarshal(rawValue, &val)
		if err != nil {
			return err
		}

		ma.AdditionalProperties[key] = val
	}

	*a = Activities(ma)

	return nil
}

// MarshalJSON encodes JSON.
func (a Activities) MarshalJSON() ([]byte, error) {
	if len(a.AdditionalProperties) == 0 {
		return json.Marshal(marshalActivities(a))
	}

	return marshalUnion(marshalActivities(a), a.AdditionalProperties)
}

// Activity structure is generated from "#/definitions/Activity".
type Activity struct {
	Uuid                 string                 `json:"uuid,omitempty"` // Unique identifier for the activity.
	AdditionalProperties map[string]interface{} `json:"-"`              // All unmatched properties.
}

type marshalActivity Activity

var knownKeysActivity = []string{
	"uuid",
}

// UnmarshalJSON decodes JSON.
func (a *Activity) UnmarshalJSON(data []byte) error {
	var err error

	ma := marshalActivity(*a)

	err = json.Unmarshal(data, &ma)
	if err != nil {
		return err
	}

	var rawMap map[string]json.RawMessage

	err = json.Unmarshal(data, &rawMap)
	if err != nil {
		rawMap = nil
	}

	for _, key := range knownKeysActivity {
		delete(rawMap, key)
	}

	for key, rawValue := range rawMap {
		if ma.AdditionalProperties == nil {
			ma.AdditionalProperties = make(map[string]interface{}, 1)
		}

		var val interface{}

		err = json.Unmarshal(rawValue, &val)
		if err != nil {
			return err
		}

		ma.AdditionalProperties[key] = val
	}

	*a = Activity(ma)

	return nil
}

// MarshalJSON encodes JSON.
func (a Activity) MarshalJSON() ([]byte, error) {
	if len(a.AdditionalProperties) == 0 {
		return json.Marshal(marshalActivity(a))
	}

	return marshalUnion(marshalActivity(a), a.AdditionalProperties)
}

func marshalUnion(maps ...interface{}) ([]byte, error) {
	result := []byte("{")
	isObject := true

	for _, m := range maps {
		j, err := json.Marshal(m)
		if err != nil {
			return nil, err
		}

		if string(j) == "{}" {
			continue
		}

		if string(j) == "null" {
			continue
		}

		if j[0] != '{' {
			if len(result) == 1 && (isObject || bytes.Equal(result, j)) {
				result = j
				isObject = false

				continue
			}

			return nil, errors.New("failed to union map: object expected, " + string(j) + " received")
		}

		if !isObject {
			return nil, errors.New("failed to union " + string(result) + " and " + string(j))
		}

		if len(result) > 1 {
			result[len(result)-1] = ','
		}

		result = append(result, j[1:]...)
	}

	// Close empty result.
	if isObject && len(result) == 1 {
		result = append(result, '}')
	}

	return result, nil
}
