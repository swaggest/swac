// Code generated by github.com/swaggest/swac <version>, DO NOT EDIT.

package foobar



import (
	"fmt"
	"io"
	"log"
	"mime/multipart"
	"net/textproto"
	"strings"
	"sync/atomic"
)

// UploadFile describes file to upload.
type UploadFile struct {
	Name        string
	ContentType string
	Content     io.ReadCloser
}

var quoteEscaper = strings.NewReplacer("\\", "\\\\", `"`, "\\\"")

func escapeQuotes(s string) string {
	return quoteEscaper.Replace(s)
}

// pipeUpload implements content piping for upload.
type pipeUpload struct {
	OnError         func(err error)
	pipeReader      *io.PipeReader
	pipeWriter      *io.PipeWriter
	multipartWriter *multipart.Writer
	closed          int32
}

func (pr *pipeUpload) Cancel(err error) {
	if !atomic.CompareAndSwapInt32(&pr.closed, 0, 1) {
		return
	}

	_ = pr.multipartWriter.Close()
	_ = pr.pipeWriter.CloseWithError(err)
	_ = pr.pipeReader.CloseWithError(err)
}

func (pr *pipeUpload) onError(err error) {
	if pr.OnError != nil {
		pr.OnError(err)
	} else {
		log.Println(err)
	}
}

func (pr *pipeUpload) close() {
	if r := recover(); r != nil {
		pr.onError(fmt.Errorf("%v", r))
	}

	if !atomic.CompareAndSwapInt32(&pr.closed, 0, 1) {
		return
	}

	if err := pr.multipartWriter.Close(); err != nil {
		pr.onError(err)
	}

	if err := pr.pipeWriter.Close(); err != nil {
		pr.onError(err)
	}
}

func (pr *pipeUpload) addFile(uf UploadFile, fieldName string) {
	if atomic.LoadInt32(&pr.closed) == 1 {
		return
	}

	contentType := uf.ContentType
	if contentType == "" {
		contentType = "application/octet-stream"
	}

	h := make(textproto.MIMEHeader)
	h.Set("Content-Disposition",
		fmt.Sprintf(`form-data; name="%s"; filename="%s"`,
			escapeQuotes(fieldName), escapeQuotes(uf.Name)))
	h.Set("Content-Type", contentType)
	part, err := pr.multipartWriter.CreatePart(h)

	if err != nil {
		if atomic.LoadInt32(&pr.closed) == 1 && err == io.ErrClosedPipe {
			return
		}

		pr.onError(err)
		return
	}

	if _, err = io.Copy(part, uf.Content); err != nil {
		pr.onError(err)

		err = uf.Content.Close()
		if err != nil {
			pr.onError(err)
		}

		return
	}

	err = uf.Content.Close()
	if err != nil {
		pr.onError(err)
	}
}

func (pr *pipeUpload) initPipe() {
	pr.pipeReader, pr.pipeWriter = io.Pipe()
	pr.multipartWriter = multipart.NewWriter(pr.pipeWriter)
}
