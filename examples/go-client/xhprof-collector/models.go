// Code generated by github.com/swaggest/swac <version>, DO NOT EDIT.

package foobar

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
)

// Profiles structure is generated from "#/components/schemas/Profiles".
type Profiles struct {
	ActiveAggregates     *[]ProfileInfo         `json:"activeAggregates,omitempty"`
	Recent               *[]ProfileInfo         `json:"recent,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`                          // All unmatched properties.
}

type marshalProfiles Profiles

var knownKeysProfiles = []string{
	"activeAggregates",
	"recent",
}

// UnmarshalJSON decodes JSON.
func (p *Profiles) UnmarshalJSON(data []byte) error {
	var err error

	mp := marshalProfiles(*p)

	err = json.Unmarshal(data, &mp)
	if err != nil {
		return err
	}

	var rawMap map[string]json.RawMessage

	err = json.Unmarshal(data, &rawMap)
	if err != nil {
		rawMap = nil
	}

	for _, key := range knownKeysProfiles {
		delete(rawMap, key)
	}

	for key, rawValue := range rawMap {
		if mp.AdditionalProperties == nil {
			mp.AdditionalProperties = make(map[string]interface{}, 1)
		}

		var val interface{}

		err = json.Unmarshal(rawValue, &val)
		if err != nil {
			return err
		}

		mp.AdditionalProperties[key] = val
	}

	*p = Profiles(mp)

	return nil
}

// MarshalJSON encodes JSON.
func (p Profiles) MarshalJSON() ([]byte, error) {
	if len(p.AdditionalProperties) == 0 {
		return json.Marshal(marshalProfiles(p))
	}

	return marshalUnion(marshalProfiles(p), p.AdditionalProperties)
}

// ProfileInfo structure is generated from "#/components/schemas/ProfileInfo".
type ProfileInfo struct {
	Addr                 *AggregatorGroup       `json:"addr,omitempty"`
	CPU                  string                 `json:"cpu,omitempty"`
	Edges                int64                  `json:"edges,omitempty"`
	Io                   string                 `json:"io,omitempty"`
	PeakMem              string                 `json:"peakMem,omitempty"`
	Profiles             int64                  `json:"profiles,omitempty"`
	Wt                   string                 `json:"wt,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`                  // All unmatched properties.
}

type marshalProfileInfo ProfileInfo

var knownKeysProfileInfo = []string{
	"addr",
	"cpu",
	"edges",
	"io",
	"peakMem",
	"profiles",
	"wt",
}

// UnmarshalJSON decodes JSON.
func (p *ProfileInfo) UnmarshalJSON(data []byte) error {
	var err error

	mp := marshalProfileInfo(*p)

	err = json.Unmarshal(data, &mp)
	if err != nil {
		return err
	}

	var rawMap map[string]json.RawMessage

	err = json.Unmarshal(data, &rawMap)
	if err != nil {
		rawMap = nil
	}

	for _, key := range knownKeysProfileInfo {
		delete(rawMap, key)
	}

	for key, rawValue := range rawMap {
		if mp.AdditionalProperties == nil {
			mp.AdditionalProperties = make(map[string]interface{}, 1)
		}

		var val interface{}

		err = json.Unmarshal(rawValue, &val)
		if err != nil {
			return err
		}

		mp.AdditionalProperties[key] = val
	}

	*p = ProfileInfo(mp)

	return nil
}

// MarshalJSON encodes JSON.
func (p ProfileInfo) MarshalJSON() ([]byte, error) {
	if len(p.AdditionalProperties) == 0 {
		return json.Marshal(marshalProfileInfo(p))
	}

	return marshalUnion(marshalProfileInfo(p), p.AdditionalProperties)
}

// AggregatorGroup structure is generated from "#/components/schemas/AggregatorGroup".
type AggregatorGroup struct {
	End                  int64                  `json:"end,omitempty"`    // Interval end UTC unix timestamp.
	ID                   string                 `json:"id,omitempty"`     // Profile ID.
	Labels               *map[string]string     `json:"labels,omitempty"`
	Start                int64                  `json:"start,omitempty"`  // Interval start UTC unix timestamp.
	AdditionalProperties map[string]interface{} `json:"-"`                // All unmatched properties.
}

type marshalAggregatorGroup AggregatorGroup

var knownKeysAggregatorGroup = []string{
	"end",
	"id",
	"labels",
	"start",
}

// UnmarshalJSON decodes JSON.
func (a *AggregatorGroup) UnmarshalJSON(data []byte) error {
	var err error

	ma := marshalAggregatorGroup(*a)

	err = json.Unmarshal(data, &ma)
	if err != nil {
		return err
	}

	var rawMap map[string]json.RawMessage

	err = json.Unmarshal(data, &rawMap)
	if err != nil {
		rawMap = nil
	}

	for _, key := range knownKeysAggregatorGroup {
		delete(rawMap, key)
	}

	for key, rawValue := range rawMap {
		if ma.AdditionalProperties == nil {
			ma.AdditionalProperties = make(map[string]interface{}, 1)
		}

		var val interface{}

		err = json.Unmarshal(rawValue, &val)
		if err != nil {
			return err
		}

		ma.AdditionalProperties[key] = val
	}

	*a = AggregatorGroup(ma)

	return nil
}

// MarshalJSON encodes JSON.
func (a AggregatorGroup) MarshalJSON() ([]byte, error) {
	if len(a.AdditionalProperties) == 0 {
		return json.Marshal(marshalAggregatorGroup(a))
	}

	return marshalUnion(marshalAggregatorGroup(a), a.AdditionalProperties)
}

// CollectProfileInput structure is generated from "#/components/schemas/CollectProfileInput".
type CollectProfileInput struct {
	// Random string created by client to identify profile.
	// Required.
	ID                   string                   `json:"id"`
	Labels               *map[string]string       `json:"labels,omitempty"`
	Meta                 *map[string]interface{}  `json:"meta,omitempty"`    // Additional context.
	Profile              *map[string]ProfileValue `json:"profile,omitempty"`
	AdditionalProperties map[string]interface{}   `json:"-"`                 // All unmatched properties.
}

type marshalCollectProfileInput CollectProfileInput

var knownKeysCollectProfileInput = []string{
	"id",
	"labels",
	"meta",
	"profile",
}

// UnmarshalJSON decodes JSON.
func (c *CollectProfileInput) UnmarshalJSON(data []byte) error {
	var err error

	mc := marshalCollectProfileInput(*c)

	err = json.Unmarshal(data, &mc)
	if err != nil {
		return err
	}

	var rawMap map[string]json.RawMessage

	err = json.Unmarshal(data, &rawMap)
	if err != nil {
		rawMap = nil
	}

	for _, key := range knownKeysCollectProfileInput {
		delete(rawMap, key)
	}

	for key, rawValue := range rawMap {
		if mc.AdditionalProperties == nil {
			mc.AdditionalProperties = make(map[string]interface{}, 1)
		}

		var val interface{}

		err = json.Unmarshal(rawValue, &val)
		if err != nil {
			return err
		}

		mc.AdditionalProperties[key] = val
	}

	*c = CollectProfileInput(mc)

	return nil
}

// MarshalJSON encodes JSON.
func (c CollectProfileInput) MarshalJSON() ([]byte, error) {
	if len(c.AdditionalProperties) == 0 {
		return json.Marshal(marshalCollectProfileInput(c))
	}

	return marshalUnion(marshalCollectProfileInput(c), c.AdditionalProperties)
}

// ProfileValue structure is generated from "#/components/schemas/ProfileValue".
type ProfileValue struct {
	As                   int64                  `json:"as,omitempty"`     // Aggregation size, count of parent profiles.
	CPU                  int64                  `json:"cpu,omitempty"`    // CPU time in microseconds.
	Ct                   int64                  `json:"ct,omitempty"`     // Count of calls.
	Io                   int64                  `json:"io,omitempty"`     // IO time in microseconds.
	MemAa                int64                  `json:"mem.aa,omitempty"` // The amount of allocated memory.
	MemNa                int64                  `json:"mem.na,omitempty"` // The sum of the number of all allocations in this function.
	MemNf                int64                  `json:"mem.nf,omitempty"` // The sum of the number of all frees in this function.
	Mu                   int64                  `json:"mu,omitempty"`     // Memory usage in bytes.
	Pmu                  int64                  `json:"pmu,omitempty"`    // Peak memory usage in bytes.
	Wt                   int64                  `json:"wt,omitempty"`     // Wall time in microseconds.
	AdditionalProperties map[string]interface{} `json:"-"`                // All unmatched properties.
}

type marshalProfileValue ProfileValue

var knownKeysProfileValue = []string{
	"as",
	"cpu",
	"ct",
	"io",
	"mem.aa",
	"mem.na",
	"mem.nf",
	"mu",
	"pmu",
	"wt",
}

// UnmarshalJSON decodes JSON.
func (p *ProfileValue) UnmarshalJSON(data []byte) error {
	var err error

	mp := marshalProfileValue(*p)

	err = json.Unmarshal(data, &mp)
	if err != nil {
		return err
	}

	var rawMap map[string]json.RawMessage

	err = json.Unmarshal(data, &rawMap)
	if err != nil {
		rawMap = nil
	}

	for _, key := range knownKeysProfileValue {
		delete(rawMap, key)
	}

	for key, rawValue := range rawMap {
		if mp.AdditionalProperties == nil {
			mp.AdditionalProperties = make(map[string]interface{}, 1)
		}

		var val interface{}

		err = json.Unmarshal(rawValue, &val)
		if err != nil {
			return err
		}

		mp.AdditionalProperties[key] = val
	}

	*p = ProfileValue(mp)

	return nil
}

// MarshalJSON encodes JSON.
func (p ProfileValue) MarshalJSON() ([]byte, error) {
	if len(p.AdditionalProperties) == 0 {
		return json.Marshal(marshalProfileValue(p))
	}

	return marshalUnion(marshalProfileValue(p), p.AdditionalProperties)
}

// RestErrResponse structure is generated from "#/components/schemas/RestErrResponse".
type RestErrResponse struct {
	Code                 int64                  `json:"code,omitempty"`    // Application-specific error code.
	Context              map[string]interface{} `json:"context,omitempty"` // Application context.
	Error                string                 `json:"error,omitempty"`   // Error message.
	Status               string                 `json:"status,omitempty"`  // Status text.
	AdditionalProperties map[string]interface{} `json:"-"`                 // All unmatched properties.
}

type marshalRestErrResponse RestErrResponse

var knownKeysRestErrResponse = []string{
	"code",
	"context",
	"error",
	"status",
}

// UnmarshalJSON decodes JSON.
func (r *RestErrResponse) UnmarshalJSON(data []byte) error {
	var err error

	mr := marshalRestErrResponse(*r)

	err = json.Unmarshal(data, &mr)
	if err != nil {
		return err
	}

	var rawMap map[string]json.RawMessage

	err = json.Unmarshal(data, &rawMap)
	if err != nil {
		rawMap = nil
	}

	for _, key := range knownKeysRestErrResponse {
		delete(rawMap, key)
	}

	for key, rawValue := range rawMap {
		if mr.AdditionalProperties == nil {
			mr.AdditionalProperties = make(map[string]interface{}, 1)
		}

		var val interface{}

		err = json.Unmarshal(rawValue, &val)
		if err != nil {
			return err
		}

		mr.AdditionalProperties[key] = val
	}

	*r = RestErrResponse(mr)

	return nil
}

// MarshalJSON encodes JSON.
func (r RestErrResponse) MarshalJSON() ([]byte, error) {
	if len(r.AdditionalProperties) == 0 {
		return json.Marshal(marshalRestErrResponse(r))
	}

	return marshalUnion(marshalRestErrResponse(r), r.AdditionalProperties)
}

// SearchOutput structure is generated from "#/components/schemas/SearchOutput".
type SearchOutput struct {
	Symbols              *[]string              `json:"symbols,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`                 // All unmatched properties.
}

type marshalSearchOutput SearchOutput

var knownKeysSearchOutput = []string{
	"symbols",
}

// UnmarshalJSON decodes JSON.
func (s *SearchOutput) UnmarshalJSON(data []byte) error {
	var err error

	ms := marshalSearchOutput(*s)

	err = json.Unmarshal(data, &ms)
	if err != nil {
		return err
	}

	var rawMap map[string]json.RawMessage

	err = json.Unmarshal(data, &rawMap)
	if err != nil {
		rawMap = nil
	}

	for _, key := range knownKeysSearchOutput {
		delete(rawMap, key)
	}

	for key, rawValue := range rawMap {
		if ms.AdditionalProperties == nil {
			ms.AdditionalProperties = make(map[string]interface{}, 1)
		}

		var val interface{}

		err = json.Unmarshal(rawValue, &val)
		if err != nil {
			return err
		}

		ms.AdditionalProperties[key] = val
	}

	*s = SearchOutput(ms)

	return nil
}

// MarshalJSON encodes JSON.
func (s SearchOutput) MarshalJSON() ([]byte, error) {
	if len(s.AdditionalProperties) == 0 {
		return json.Marshal(marshalSearchOutput(s))
	}

	return marshalUnion(marshalSearchOutput(s), s.AdditionalProperties)
}

// SymbolStatOutput structure is generated from "#/components/schemas/SymbolStatOutput".
type SymbolStatOutput struct {
	Callees              map[string]RenderValueStat `json:"callees,omitempty"`   // Callees stat.
	Callers              map[string]RenderValueStat `json:"callers,omitempty"`   // Callers stat.
	Exclusive            *RenderValueStat           `json:"exclusive,omitempty"`
	Inclusive            *RenderValueStat           `json:"inclusive,omitempty"`
	AdditionalProperties map[string]interface{}     `json:"-"`                   // All unmatched properties.
}

type marshalSymbolStatOutput SymbolStatOutput

var knownKeysSymbolStatOutput = []string{
	"callees",
	"callers",
	"exclusive",
	"inclusive",
}

// UnmarshalJSON decodes JSON.
func (s *SymbolStatOutput) UnmarshalJSON(data []byte) error {
	var err error

	ms := marshalSymbolStatOutput(*s)

	err = json.Unmarshal(data, &ms)
	if err != nil {
		return err
	}

	var rawMap map[string]json.RawMessage

	err = json.Unmarshal(data, &rawMap)
	if err != nil {
		rawMap = nil
	}

	for _, key := range knownKeysSymbolStatOutput {
		delete(rawMap, key)
	}

	for key, rawValue := range rawMap {
		if ms.AdditionalProperties == nil {
			ms.AdditionalProperties = make(map[string]interface{}, 1)
		}

		var val interface{}

		err = json.Unmarshal(rawValue, &val)
		if err != nil {
			return err
		}

		ms.AdditionalProperties[key] = val
	}

	*s = SymbolStatOutput(ms)

	return nil
}

// MarshalJSON encodes JSON.
func (s SymbolStatOutput) MarshalJSON() ([]byte, error) {
	if len(s.AdditionalProperties) == 0 {
		return json.Marshal(marshalSymbolStatOutput(s))
	}

	return marshalUnion(marshalSymbolStatOutput(s), s.AdditionalProperties)
}

// RenderValueStat structure is generated from "#/components/schemas/RenderValueStat".
type RenderValueStat struct {
	As                   string                 `json:"as,omitempty"`
	CPU                  string                 `json:"cpu,omitempty"`
	Cpuf                 string                 `json:"cpuf,omitempty"`
	Ct                   string                 `json:"ct,omitempty"`
	Ctf                  string                 `json:"ctf,omitempty"`
	Io                   string                 `json:"io,omitempty"`
	Iof                  string                 `json:"iof,omitempty"`
	Ma                   string                 `json:"ma,omitempty"`
	Mac                  string                 `json:"mac,omitempty"`
	Mf                   string                 `json:"mf,omitempty"`
	Mu                   string                 `json:"mu,omitempty"`
	Pmu                  string                 `json:"pmu,omitempty"`
	Wt                   string                 `json:"wt,omitempty"`
	Wtf                  string                 `json:"wtf,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`              // All unmatched properties.
}

type marshalRenderValueStat RenderValueStat

var knownKeysRenderValueStat = []string{
	"as",
	"cpu",
	"cpuf",
	"ct",
	"ctf",
	"io",
	"iof",
	"ma",
	"mac",
	"mf",
	"mu",
	"pmu",
	"wt",
	"wtf",
}

// UnmarshalJSON decodes JSON.
func (r *RenderValueStat) UnmarshalJSON(data []byte) error {
	var err error

	mr := marshalRenderValueStat(*r)

	err = json.Unmarshal(data, &mr)
	if err != nil {
		return err
	}

	var rawMap map[string]json.RawMessage

	err = json.Unmarshal(data, &rawMap)
	if err != nil {
		rawMap = nil
	}

	for _, key := range knownKeysRenderValueStat {
		delete(rawMap, key)
	}

	for key, rawValue := range rawMap {
		if mr.AdditionalProperties == nil {
			mr.AdditionalProperties = make(map[string]interface{}, 1)
		}

		var val interface{}

		err = json.Unmarshal(rawValue, &val)
		if err != nil {
			return err
		}

		mr.AdditionalProperties[key] = val
	}

	*r = RenderValueStat(mr)

	return nil
}

// MarshalJSON encodes JSON.
func (r RenderValueStat) MarshalJSON() ([]byte, error) {
	if len(r.AdditionalProperties) == 0 {
		return json.Marshal(marshalRenderValueStat(r))
	}

	return marshalUnion(marshalRenderValueStat(r), r.AdditionalProperties)
}

// TraceInfo structure is generated from "#/components/schemas/TraceInfo".
type TraceInfo struct {
	Hash                 string                 `json:"hash,omitempty"`
	Stat                 *RenderValueStat       `json:"stat,omitempty"`
	Symbol               string                 `json:"symbol,omitempty"`
	Trace                *[]string              `json:"trace,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`                // All unmatched properties.
}

type marshalTraceInfo TraceInfo

var knownKeysTraceInfo = []string{
	"hash",
	"stat",
	"symbol",
	"trace",
}

// UnmarshalJSON decodes JSON.
func (t *TraceInfo) UnmarshalJSON(data []byte) error {
	var err error

	mt := marshalTraceInfo(*t)

	err = json.Unmarshal(data, &mt)
	if err != nil {
		return err
	}

	var rawMap map[string]json.RawMessage

	err = json.Unmarshal(data, &rawMap)
	if err != nil {
		rawMap = nil
	}

	for _, key := range knownKeysTraceInfo {
		delete(rawMap, key)
	}

	for key, rawValue := range rawMap {
		if mt.AdditionalProperties == nil {
			mt.AdditionalProperties = make(map[string]interface{}, 1)
		}

		var val interface{}

		err = json.Unmarshal(rawValue, &val)
		if err != nil {
			return err
		}

		mt.AdditionalProperties[key] = val
	}

	*t = TraceInfo(mt)

	return nil
}

// MarshalJSON encodes JSON.
func (t TraceInfo) MarshalJSON() ([]byte, error) {
	if len(t.AdditionalProperties) == 0 {
		return json.Marshal(marshalTraceInfo(t))
	}

	return marshalUnion(marshalTraceInfo(t), t.AdditionalProperties)
}

// GraphResource is an enum type.
type GraphResource string

// GraphResource values enumeration.
const (
	GraphResourceWt = GraphResource("wt")
	GraphResourceCPU = GraphResource("cpu")
	GraphResourceIo = GraphResource("io")
)

// MarshalJSON encodes JSON.
func (i GraphResource) MarshalJSON() ([]byte, error) {
	switch i {
	case GraphResourceWt:
	case GraphResourceCPU:
	case GraphResourceIo:

	default:
		return nil, fmt.Errorf("unexpected GraphResource value: %v", i)
	}

	return json.Marshal(string(i))
}

// UnmarshalJSON decodes JSON.
func (i *GraphResource) UnmarshalJSON(data []byte) error {
	var ii string

	err := json.Unmarshal(data, &ii)
	if err != nil {
		return err
	}

	v := GraphResource(ii)

	switch v {
	case GraphResourceWt:
	case GraphResourceCPU:
	case GraphResourceIo:

	default:
		return fmt.Errorf("unexpected GraphResource value: %v", v)
	}

	*i = v

	return nil
}

func marshalUnion(maps ...interface{}) ([]byte, error) {
	result := []byte("{")
	isObject := true

	for _, m := range maps {
		j, err := json.Marshal(m)
		if err != nil {
			return nil, err
		}

		if string(j) == "{}" {
			continue
		}

		if string(j) == "null" {
			continue
		}

		if j[0] != '{' {
			if len(result) == 1 && (isObject || bytes.Equal(result, j)) {
				result = j
				isObject = false

				continue
			}

			return nil, errors.New("failed to union map: object expected, " + string(j) + " received")
		}

		if !isObject {
			return nil, errors.New("failed to union " + string(result) + " and " + string(j))
		}

		if len(result) > 1 {
			result[len(result)-1] = ','
		}

		result = append(result, j[1:]...)
	}

	// Close empty result.
	if isObject && len(result) == 1 {
		result = append(result, '}')
	}

	return result, nil
}
