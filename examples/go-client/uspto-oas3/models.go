// Code generated by github.com/swaggest/swac <version>, DO NOT EDIT.

package uspto

import (
	"bytes"
	"encoding/json"
	"errors"
)

// DataSetList structure is generated from "#/components/schemas/dataSetList".
type DataSetList struct {
	Total                int64                  `json:"total,omitempty"`
	Apis                 []DataSetListApisItems `json:"apis,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`               // All unmatched properties.
}

type marshalDataSetList DataSetList

var knownKeysDataSetList = []string{
	"total",
	"apis",
}

// UnmarshalJSON decodes JSON.
func (d *DataSetList) UnmarshalJSON(data []byte) error {
	var err error

	md := marshalDataSetList(*d)

	err = json.Unmarshal(data, &md)
	if err != nil {
		return err
	}

	var rawMap map[string]json.RawMessage

	err = json.Unmarshal(data, &rawMap)
	if err != nil {
		rawMap = nil
	}

	for _, key := range knownKeysDataSetList {
		delete(rawMap, key)
	}

	for key, rawValue := range rawMap {
		if md.AdditionalProperties == nil {
			md.AdditionalProperties = make(map[string]interface{}, 1)
		}

		var val interface{}

		err = json.Unmarshal(rawValue, &val)
		if err != nil {
			return err
		}

		md.AdditionalProperties[key] = val
	}

	*d = DataSetList(md)

	return nil
}

// MarshalJSON encodes JSON.
func (d DataSetList) MarshalJSON() ([]byte, error) {
	if len(d.AdditionalProperties) == 0 {
		return json.Marshal(marshalDataSetList(d))
	}

	return marshalUnion(marshalDataSetList(d), d.AdditionalProperties)
}

// DataSetListApisItems structure is generated from "#/components/schemas/dataSetList->apis->items".
type DataSetListApisItems struct {
	APIKey               string                 `json:"apiKey,omitempty"`              // To be used as a dataset parameter value.
	APIVersionNumber     string                 `json:"apiVersionNumber,omitempty"`    // To be used as a version parameter value.
	// The URL describing the dataset's fields.
	// Format: uriref.
	APIURL               string                 `json:"apiUrl,omitempty"`
	// A URL to the API console for each API.
	// Format: uriref.
	APIDocumentationURL  string                 `json:"apiDocumentationUrl,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`                             // All unmatched properties.
}

type marshalDataSetListApisItems DataSetListApisItems

var knownKeysDataSetListApisItems = []string{
	"apiKey",
	"apiVersionNumber",
	"apiUrl",
	"apiDocumentationUrl",
}

// UnmarshalJSON decodes JSON.
func (d *DataSetListApisItems) UnmarshalJSON(data []byte) error {
	var err error

	md := marshalDataSetListApisItems(*d)

	err = json.Unmarshal(data, &md)
	if err != nil {
		return err
	}

	var rawMap map[string]json.RawMessage

	err = json.Unmarshal(data, &rawMap)
	if err != nil {
		rawMap = nil
	}

	for _, key := range knownKeysDataSetListApisItems {
		delete(rawMap, key)
	}

	for key, rawValue := range rawMap {
		if md.AdditionalProperties == nil {
			md.AdditionalProperties = make(map[string]interface{}, 1)
		}

		var val interface{}

		err = json.Unmarshal(rawValue, &val)
		if err != nil {
			return err
		}

		md.AdditionalProperties[key] = val
	}

	*d = DataSetListApisItems(md)

	return nil
}

// MarshalJSON encodes JSON.
func (d DataSetListApisItems) MarshalJSON() ([]byte, error) {
	if len(d.AdditionalProperties) == 0 {
		return json.Marshal(marshalDataSetListApisItems(d))
	}

	return marshalUnion(marshalDataSetListApisItems(d), d.AdditionalProperties)
}

func marshalUnion(maps ...interface{}) ([]byte, error) {
	result := []byte("{")
	isObject := true

	for _, m := range maps {
		j, err := json.Marshal(m)
		if err != nil {
			return nil, err
		}

		if string(j) == "{}" {
			continue
		}

		if string(j) == "null" {
			continue
		}

		if j[0] != '{' {
			if len(result) == 1 && (isObject || bytes.Equal(result, j)) {
				result = j
				isObject = false

				continue
			}

			return nil, errors.New("failed to union map: object expected, " + string(j) + " received")
		}

		if !isObject {
			return nil, errors.New("failed to union " + string(result) + " and " + string(j))
		}

		if len(result) > 1 {
			result[len(result)-1] = ','
		}

		result = append(result, j[1:]...)
	}

	// Close empty result.
	if isObject && len(result) == 1 {
		result = append(result, '}')
	}

	return result, nil
}
