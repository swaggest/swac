// Code generated by github.com/swaggest/swac <version>, DO NOT EDIT.

package foobar

import (
	"bytes"
	"encoding/json"
	"errors"
	"time"
)

// RestErrResponse structure is generated from "#/components/schemas/RestErrResponse".
type RestErrResponse struct {
	Code                 int64                  `json:"code,omitempty"`
	Context              map[string]interface{} `json:"context,omitempty"`
	Error                string                 `json:"error,omitempty"`
	Status               string                 `json:"status,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`                 // All unmatched properties.
}

type marshalRestErrResponse RestErrResponse

var knownKeysRestErrResponse = []string{
	"code",
	"context",
	"error",
	"status",
}

// UnmarshalJSON decodes JSON.
func (r *RestErrResponse) UnmarshalJSON(data []byte) error {
	var err error

	mr := marshalRestErrResponse(*r)

	err = json.Unmarshal(data, &mr)
	if err != nil {
		return err
	}

	var rawMap map[string]json.RawMessage

	err = json.Unmarshal(data, &rawMap)
	if err != nil {
		rawMap = nil
	}

	for _, key := range knownKeysRestErrResponse {
		delete(rawMap, key)
	}

	for key, rawValue := range rawMap {
		if mr.AdditionalProperties == nil {
			mr.AdditionalProperties = make(map[string]interface{}, 1)
		}

		var val interface{}

		err = json.Unmarshal(rawValue, &val)
		if err != nil {
			return err
		}

		mr.AdditionalProperties[key] = val
	}

	*r = RestErrResponse(mr)

	return nil
}

// MarshalJSON encodes JSON.
func (r RestErrResponse) MarshalJSON() ([]byte, error) {
	if len(r.AdditionalProperties) == 0 {
		return json.Marshal(marshalRestErrResponse(r))
	}

	return marshalUnion(marshalRestErrResponse(r), r.AdditionalProperties)
}

// PlaceEntity structure is generated from "#/components/schemas/PlaceEntity".
type PlaceEntity struct {
	PlaceID              int64                  `json:"placeId,omitempty"`
	CreatedAt            *time.Time             `json:"createdAt,omitempty"` // Format: date-time.
	FoxID                int64                  `json:"foxId,omitempty"`
	// Format: uuid.
	// Required.
	FoxUuid              string                 `json:"foxUuid"`
	FooID                int64                  `json:"fooId"`               // Required.
	BarName              string                 `json:"barName"`             // Required.
	AdditionalProperties map[string]interface{} `json:"-"`                   // All unmatched properties.
}

type marshalPlaceEntity PlaceEntity

var knownKeysPlaceEntity = []string{
	"placeId",
	"createdAt",
	"foxId",
	"foxUuid",
	"fooId",
	"barName",
}

// UnmarshalJSON decodes JSON.
func (p *PlaceEntity) UnmarshalJSON(data []byte) error {
	var err error

	mp := marshalPlaceEntity(*p)

	err = json.Unmarshal(data, &mp)
	if err != nil {
		return err
	}

	var rawMap map[string]json.RawMessage

	err = json.Unmarshal(data, &rawMap)
	if err != nil {
		rawMap = nil
	}

	for _, key := range knownKeysPlaceEntity {
		delete(rawMap, key)
	}

	for key, rawValue := range rawMap {
		if mp.AdditionalProperties == nil {
			mp.AdditionalProperties = make(map[string]interface{}, 1)
		}

		var val interface{}

		err = json.Unmarshal(rawValue, &val)
		if err != nil {
			return err
		}

		mp.AdditionalProperties[key] = val
	}

	*p = PlaceEntity(mp)

	return nil
}

// MarshalJSON encodes JSON.
func (p PlaceEntity) MarshalJSON() ([]byte, error) {
	if len(p.AdditionalProperties) == 0 {
		return json.Marshal(marshalPlaceEntity(p))
	}

	return marshalUnion(marshalPlaceEntity(p), p.AdditionalProperties)
}

// UsecaseCreatePlaceInput structure is generated from "#/components/schemas/UsecaseCreatePlaceInput".
type UsecaseCreatePlaceInput struct {
	FoxID                int64                  `json:"foxId,omitempty"`
	// Format: uuid.
	// Required.
	FoxUuid              string                 `json:"foxUuid"`
	FooID                int64                  `json:"fooId"`           // Required.
	BarName              string                 `json:"barName"`         // Required.
	AdditionalProperties map[string]interface{} `json:"-"`               // All unmatched properties.
}

type marshalUsecaseCreatePlaceInput UsecaseCreatePlaceInput

var knownKeysUsecaseCreatePlaceInput = []string{
	"foxId",
	"foxUuid",
	"fooId",
	"barName",
}

// UnmarshalJSON decodes JSON.
func (u *UsecaseCreatePlaceInput) UnmarshalJSON(data []byte) error {
	var err error

	mu := marshalUsecaseCreatePlaceInput(*u)

	err = json.Unmarshal(data, &mu)
	if err != nil {
		return err
	}

	var rawMap map[string]json.RawMessage

	err = json.Unmarshal(data, &rawMap)
	if err != nil {
		rawMap = nil
	}

	for _, key := range knownKeysUsecaseCreatePlaceInput {
		delete(rawMap, key)
	}

	for key, rawValue := range rawMap {
		if mu.AdditionalProperties == nil {
			mu.AdditionalProperties = make(map[string]interface{}, 1)
		}

		var val interface{}

		err = json.Unmarshal(rawValue, &val)
		if err != nil {
			return err
		}

		mu.AdditionalProperties[key] = val
	}

	*u = UsecaseCreatePlaceInput(mu)

	return nil
}

// MarshalJSON encodes JSON.
func (u UsecaseCreatePlaceInput) MarshalJSON() ([]byte, error) {
	if len(u.AdditionalProperties) == 0 {
		return json.Marshal(marshalUsecaseCreatePlaceInput(u))
	}

	return marshalUnion(marshalUsecaseCreatePlaceInput(u), u.AdditionalProperties)
}

// UsecaseFooInfo structure is generated from "#/components/schemas/UsecaseFooInfo".
type UsecaseFooInfo struct {
	ActivateSince          *time.Time                    `json:"activateSince,omitempty"`          // Format: date-time.
	ActivateTill           *time.Time                    `json:"activateTill,omitempty"`           // Format: date-time.
	AvailableForActivation bool                          `json:"availableForActivation,omitempty"`
	// Acme Mille.
	// Value must match pattern: `^[a-zA-Z]{2}$`.
	// Required.
	Mille                  string                        `json:"mille"`
	CreatedAt              *time.Time                    `json:"createdAt,omitempty"`              // Format: date-time.
	DeletedAt              *time.Time                    `json:"deletedAt,omitempty"`              // Format: date-time.
	FooID                  int64                         `json:"fooId,omitempty"`
	LocalActivation        map[string]FooLocalActivation `json:"localActivation,omitempty"`
	UselyKey               string                        `json:"uselyKey"`                         // Required.
	Overlap                []FooEntity                   `json:"overlap,omitempty"`
	PotatoFamily           string                        `json:"potatoFamily"`                     // Required.
	UpdatedAt              *time.Time                    `json:"updatedAt,omitempty"`              // Format: date-time.
	BarRules               *map[string]FooBarRule        `json:"barRules"`                         // Required.
	// Acme Look.
	// Value must match pattern: `^[0-9]{4}-W(0[1-9]|[1-4][0-9]|5[0-3])$`.
	// Required.
	LookEnd                string                        `json:"lookEnd"`
	// Acme Look.
	// Value must match pattern: `^[0-9]{4}-W(0[1-9]|[1-4][0-9]|5[0-3])$`.
	// Required.
	LookStart              string                        `json:"lookStart"`
	AdditionalProperties   map[string]interface{}        `json:"-"`                                // All unmatched properties.
}

type marshalUsecaseFooInfo UsecaseFooInfo

var knownKeysUsecaseFooInfo = []string{
	"activateSince",
	"activateTill",
	"availableForActivation",
	"mille",
	"createdAt",
	"deletedAt",
	"fooId",
	"localActivation",
	"uselyKey",
	"overlap",
	"potatoFamily",
	"updatedAt",
	"barRules",
	"lookEnd",
	"lookStart",
}

// UnmarshalJSON decodes JSON.
func (u *UsecaseFooInfo) UnmarshalJSON(data []byte) error {
	var err error

	mu := marshalUsecaseFooInfo(*u)

	err = json.Unmarshal(data, &mu)
	if err != nil {
		return err
	}

	var rawMap map[string]json.RawMessage

	err = json.Unmarshal(data, &rawMap)
	if err != nil {
		rawMap = nil
	}

	for _, key := range knownKeysUsecaseFooInfo {
		delete(rawMap, key)
	}

	for key, rawValue := range rawMap {
		if mu.AdditionalProperties == nil {
			mu.AdditionalProperties = make(map[string]interface{}, 1)
		}

		var val interface{}

		err = json.Unmarshal(rawValue, &val)
		if err != nil {
			return err
		}

		mu.AdditionalProperties[key] = val
	}

	*u = UsecaseFooInfo(mu)

	return nil
}

// MarshalJSON encodes JSON.
func (u UsecaseFooInfo) MarshalJSON() ([]byte, error) {
	if len(u.AdditionalProperties) == 0 {
		return json.Marshal(marshalUsecaseFooInfo(u))
	}

	return marshalUnion(marshalUsecaseFooInfo(u), u.AdditionalProperties)
}

// FooLocalActivation structure is generated from "#/components/schemas/FooLocalActivation".
type FooLocalActivation struct {
	MaxRoxesReceived     *int64                 `json:"maxRoxesReceived"`
	MinRoxesReceived     *int64                 `json:"minRoxesReceived"`
	AdditionalProperties map[string]interface{} `json:"-"`                // All unmatched properties.
}

type marshalFooLocalActivation FooLocalActivation

var knownKeysFooLocalActivation = []string{
	"maxRoxesReceived",
	"minRoxesReceived",
}

// UnmarshalJSON decodes JSON.
func (f *FooLocalActivation) UnmarshalJSON(data []byte) error {
	var err error

	mf := marshalFooLocalActivation(*f)

	err = json.Unmarshal(data, &mf)
	if err != nil {
		return err
	}

	var rawMap map[string]json.RawMessage

	err = json.Unmarshal(data, &rawMap)
	if err != nil {
		rawMap = nil
	}

	for _, key := range knownKeysFooLocalActivation {
		delete(rawMap, key)
	}

	for key, rawValue := range rawMap {
		if mf.AdditionalProperties == nil {
			mf.AdditionalProperties = make(map[string]interface{}, 1)
		}

		var val interface{}

		err = json.Unmarshal(rawValue, &val)
		if err != nil {
			return err
		}

		mf.AdditionalProperties[key] = val
	}

	*f = FooLocalActivation(mf)

	return nil
}

// MarshalJSON encodes JSON.
func (f FooLocalActivation) MarshalJSON() ([]byte, error) {
	if len(f.AdditionalProperties) == 0 {
		return json.Marshal(marshalFooLocalActivation(f))
	}

	return marshalUnion(marshalFooLocalActivation(f), f.AdditionalProperties)
}

// FooEntity structure is generated from "#/components/schemas/FooEntity".
type FooEntity struct {
	ActivateSince        *time.Time                    `json:"activateSince,omitempty"`   // Format: date-time.
	ActivateTill         *time.Time                    `json:"activateTill,omitempty"`    // Format: date-time.
	// Acme Mille.
	// Value must match pattern: `^[a-zA-Z]{2}$`.
	// Required.
	Mille                string                        `json:"mille"`
	CreatedAt            *time.Time                    `json:"createdAt,omitempty"`       // Format: date-time.
	DeletedAt            *time.Time                    `json:"deletedAt,omitempty"`       // Format: date-time.
	FooID                int64                         `json:"fooId,omitempty"`
	LocalActivation      map[string]FooLocalActivation `json:"localActivation,omitempty"`
	UselyKey             string                        `json:"uselyKey"`                  // Required.
	Overlap              []FooEntity                   `json:"overlap,omitempty"`
	PotatoFamily         string                        `json:"potatoFamily"`              // Required.
	UpdatedAt            *time.Time                    `json:"updatedAt,omitempty"`       // Format: date-time.
	BarRules             *map[string]FooBarRule        `json:"barRules"`                  // Required.
	// Acme Look.
	// Value must match pattern: `^[0-9]{4}-W(0[1-9]|[1-4][0-9]|5[0-3])$`.
	// Required.
	LookEnd              string                        `json:"lookEnd"`
	// Acme Look.
	// Value must match pattern: `^[0-9]{4}-W(0[1-9]|[1-4][0-9]|5[0-3])$`.
	// Required.
	LookStart            string                        `json:"lookStart"`
	AdditionalProperties map[string]interface{}        `json:"-"`                         // All unmatched properties.
}

type marshalFooEntity FooEntity

var knownKeysFooEntity = []string{
	"activateSince",
	"activateTill",
	"mille",
	"createdAt",
	"deletedAt",
	"fooId",
	"localActivation",
	"uselyKey",
	"overlap",
	"potatoFamily",
	"updatedAt",
	"barRules",
	"lookEnd",
	"lookStart",
}

// UnmarshalJSON decodes JSON.
func (f *FooEntity) UnmarshalJSON(data []byte) error {
	var err error

	mf := marshalFooEntity(*f)

	err = json.Unmarshal(data, &mf)
	if err != nil {
		return err
	}

	var rawMap map[string]json.RawMessage

	err = json.Unmarshal(data, &rawMap)
	if err != nil {
		rawMap = nil
	}

	for _, key := range knownKeysFooEntity {
		delete(rawMap, key)
	}

	for key, rawValue := range rawMap {
		if mf.AdditionalProperties == nil {
			mf.AdditionalProperties = make(map[string]interface{}, 1)
		}

		var val interface{}

		err = json.Unmarshal(rawValue, &val)
		if err != nil {
			return err
		}

		mf.AdditionalProperties[key] = val
	}

	*f = FooEntity(mf)

	return nil
}

// MarshalJSON encodes JSON.
func (f FooEntity) MarshalJSON() ([]byte, error) {
	if len(f.AdditionalProperties) == 0 {
		return json.Marshal(marshalFooEntity(f))
	}

	return marshalUnion(marshalFooEntity(f), f.AdditionalProperties)
}

// FooBarRule structure is generated from "#/components/schemas/FooBarRule".
type FooBarRule struct {
	CustomLiePreferences []LiesPreference       `json:"customLiePreferences,omitempty"`
	CustomModularity     *[]LiesModularity      `json:"customModularity,omitempty"`
	CustomSoups          map[string]string      `json:"customSoups,omitempty"`
	HideCarrots          []int64                `json:"hideCarrots,omitempty"`
	AreaTagsByCarrots    map[string][]string    `json:"areaTagsByCarrots,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`                              // All unmatched properties.
}

type marshalFooBarRule FooBarRule

var knownKeysFooBarRule = []string{
	"customLiePreferences",
	"customModularity",
	"customSoups",
	"hideCarrots",
	"areaTagsByCarrots",
}

// UnmarshalJSON decodes JSON.
func (f *FooBarRule) UnmarshalJSON(data []byte) error {
	var err error

	mf := marshalFooBarRule(*f)

	err = json.Unmarshal(data, &mf)
	if err != nil {
		return err
	}

	var rawMap map[string]json.RawMessage

	err = json.Unmarshal(data, &rawMap)
	if err != nil {
		rawMap = nil
	}

	for _, key := range knownKeysFooBarRule {
		delete(rawMap, key)
	}

	for key, rawValue := range rawMap {
		if mf.AdditionalProperties == nil {
			mf.AdditionalProperties = make(map[string]interface{}, 1)
		}

		var val interface{}

		err = json.Unmarshal(rawValue, &val)
		if err != nil {
			return err
		}

		mf.AdditionalProperties[key] = val
	}

	*f = FooBarRule(mf)

	return nil
}

// MarshalJSON encodes JSON.
func (f FooBarRule) MarshalJSON() ([]byte, error) {
	if len(f.AdditionalProperties) == 0 {
		return json.Marshal(marshalFooBarRule(f))
	}

	return marshalUnion(marshalFooBarRule(f), f.AdditionalProperties)
}

// LiesPreference structure is generated from "#/components/schemas/LiesPreference".
type LiesPreference struct {
	Other                *[]int64               `json:"other,omitempty"`
	Preset               string                 `json:"preset,omitempty"`
	Recommended          *[]int64               `json:"recommended,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`                     // All unmatched properties.
}

type marshalLiesPreference LiesPreference

var knownKeysLiesPreference = []string{
	"other",
	"preset",
	"recommended",
}

// UnmarshalJSON decodes JSON.
func (l *LiesPreference) UnmarshalJSON(data []byte) error {
	var err error

	ml := marshalLiesPreference(*l)

	err = json.Unmarshal(data, &ml)
	if err != nil {
		return err
	}

	var rawMap map[string]json.RawMessage

	err = json.Unmarshal(data, &rawMap)
	if err != nil {
		rawMap = nil
	}

	for _, key := range knownKeysLiesPreference {
		delete(rawMap, key)
	}

	for key, rawValue := range rawMap {
		if ml.AdditionalProperties == nil {
			ml.AdditionalProperties = make(map[string]interface{}, 1)
		}

		var val interface{}

		err = json.Unmarshal(rawValue, &val)
		if err != nil {
			return err
		}

		ml.AdditionalProperties[key] = val
	}

	*l = LiesPreference(ml)

	return nil
}

// MarshalJSON encodes JSON.
func (l LiesPreference) MarshalJSON() ([]byte, error) {
	if len(l.AdditionalProperties) == 0 {
		return json.Marshal(marshalLiesPreference(l))
	}

	return marshalUnion(marshalLiesPreference(l), l.AdditionalProperties)
}

// LiesModularity structure is generated from "#/components/schemas/LiesModularity".
type LiesModularity struct {
	AddOns               *[]LiesModularityAddOns `json:"addOns,omitempty"`
	AddOnsHeadline       *string                 `json:"addOnsHeadline"`
	DefaultCarrotIndex   int64                   `json:"defaultCarrotIndex,omitempty"`
	NoAddOnsDefaultTitle *string                 `json:"noAddOnsDefaultTitle"`
	NoBarsDefaultTitle   *string                 `json:"noBarsDefaultTitle"`
	PromoTitle           *string                 `json:"promoTitle"`
	Bars                 *[]LiesModularityBar    `json:"bars,omitempty"`
	BarsHeadline         *string                 `json:"barsHeadline"`
	AdditionalProperties map[string]interface{}  `json:"-"`                            // All unmatched properties.
}

type marshalLiesModularity LiesModularity

var knownKeysLiesModularity = []string{
	"addOns",
	"addOnsHeadline",
	"defaultCarrotIndex",
	"noAddOnsDefaultTitle",
	"noBarsDefaultTitle",
	"promoTitle",
	"bars",
	"barsHeadline",
}

// UnmarshalJSON decodes JSON.
func (l *LiesModularity) UnmarshalJSON(data []byte) error {
	var err error

	ml := marshalLiesModularity(*l)

	err = json.Unmarshal(data, &ml)
	if err != nil {
		return err
	}

	var rawMap map[string]json.RawMessage

	err = json.Unmarshal(data, &rawMap)
	if err != nil {
		rawMap = nil
	}

	for _, key := range knownKeysLiesModularity {
		delete(rawMap, key)
	}

	for key, rawValue := range rawMap {
		if ml.AdditionalProperties == nil {
			ml.AdditionalProperties = make(map[string]interface{}, 1)
		}

		var val interface{}

		err = json.Unmarshal(rawValue, &val)
		if err != nil {
			return err
		}

		ml.AdditionalProperties[key] = val
	}

	*l = LiesModularity(ml)

	return nil
}

// MarshalJSON encodes JSON.
func (l LiesModularity) MarshalJSON() ([]byte, error) {
	if len(l.AdditionalProperties) == 0 {
		return json.Marshal(marshalLiesModularity(l))
	}

	return marshalUnion(marshalLiesModularity(l), l.AdditionalProperties)
}

// LiesModularityAddOns structure is generated from "#/components/schemas/LiesModularityAddOns".
type LiesModularityAddOns struct {
	Index                int64                  `json:"index,omitempty"`
	Title                string                 `json:"title,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`               // All unmatched properties.
}

type marshalLiesModularityAddOns LiesModularityAddOns

var knownKeysLiesModularityAddOns = []string{
	"index",
	"title",
}

// UnmarshalJSON decodes JSON.
func (l *LiesModularityAddOns) UnmarshalJSON(data []byte) error {
	var err error

	ml := marshalLiesModularityAddOns(*l)

	err = json.Unmarshal(data, &ml)
	if err != nil {
		return err
	}

	var rawMap map[string]json.RawMessage

	err = json.Unmarshal(data, &rawMap)
	if err != nil {
		rawMap = nil
	}

	for _, key := range knownKeysLiesModularityAddOns {
		delete(rawMap, key)
	}

	for key, rawValue := range rawMap {
		if ml.AdditionalProperties == nil {
			ml.AdditionalProperties = make(map[string]interface{}, 1)
		}

		var val interface{}

		err = json.Unmarshal(rawValue, &val)
		if err != nil {
			return err
		}

		ml.AdditionalProperties[key] = val
	}

	*l = LiesModularityAddOns(ml)

	return nil
}

// MarshalJSON encodes JSON.
func (l LiesModularityAddOns) MarshalJSON() ([]byte, error) {
	if len(l.AdditionalProperties) == 0 {
		return json.Marshal(marshalLiesModularityAddOns(l))
	}

	return marshalUnion(marshalLiesModularityAddOns(l), l.AdditionalProperties)
}

// LiesModularityBar structure is generated from "#/components/schemas/LiesModularityBar".
type LiesModularityBar struct {
	Index                int64                  `json:"index,omitempty"`
	Title                *string                `json:"title"`
	AdditionalProperties map[string]interface{} `json:"-"`               // All unmatched properties.
}

type marshalLiesModularityBar LiesModularityBar

var knownKeysLiesModularityBar = []string{
	"index",
	"title",
}

// UnmarshalJSON decodes JSON.
func (l *LiesModularityBar) UnmarshalJSON(data []byte) error {
	var err error

	ml := marshalLiesModularityBar(*l)

	err = json.Unmarshal(data, &ml)
	if err != nil {
		return err
	}

	var rawMap map[string]json.RawMessage

	err = json.Unmarshal(data, &rawMap)
	if err != nil {
		rawMap = nil
	}

	for _, key := range knownKeysLiesModularityBar {
		delete(rawMap, key)
	}

	for key, rawValue := range rawMap {
		if ml.AdditionalProperties == nil {
			ml.AdditionalProperties = make(map[string]interface{}, 1)
		}

		var val interface{}

		err = json.Unmarshal(rawValue, &val)
		if err != nil {
			return err
		}

		ml.AdditionalProperties[key] = val
	}

	*l = LiesModularityBar(ml)

	return nil
}

// MarshalJSON encodes JSON.
func (l LiesModularityBar) MarshalJSON() ([]byte, error) {
	if len(l.AdditionalProperties) == 0 {
		return json.Marshal(marshalLiesModularityBar(l))
	}

	return marshalUnion(marshalLiesModularityBar(l), l.AdditionalProperties)
}

// FooValue structure is generated from "#/components/schemas/FooValue".
type FooValue struct {
	ActivateSince        *time.Time                    `json:"activateSince,omitempty"`   // Format: date-time.
	ActivateTill         *time.Time                    `json:"activateTill,omitempty"`    // Format: date-time.
	// Acme Mille.
	// Value must match pattern: `^[a-zA-Z]{2}$`.
	// Required.
	Mille                string                        `json:"mille"`
	LocalActivation      map[string]FooLocalActivation `json:"localActivation,omitempty"`
	UselyKey             string                        `json:"uselyKey"`                  // Required.
	PotatoFamily         string                        `json:"potatoFamily"`              // Required.
	BarRules             *map[string]FooBarRule        `json:"barRules"`                  // Required.
	// Acme Look.
	// Value must match pattern: `^[0-9]{4}-W(0[1-9]|[1-4][0-9]|5[0-3])$`.
	// Required.
	LookEnd              string                        `json:"lookEnd"`
	// Acme Look.
	// Value must match pattern: `^[0-9]{4}-W(0[1-9]|[1-4][0-9]|5[0-3])$`.
	// Required.
	LookStart            string                        `json:"lookStart"`
	AdditionalProperties map[string]interface{}        `json:"-"`                         // All unmatched properties.
}

type marshalFooValue FooValue

var knownKeysFooValue = []string{
	"activateSince",
	"activateTill",
	"mille",
	"localActivation",
	"uselyKey",
	"potatoFamily",
	"barRules",
	"lookEnd",
	"lookStart",
}

// UnmarshalJSON decodes JSON.
func (f *FooValue) UnmarshalJSON(data []byte) error {
	var err error

	mf := marshalFooValue(*f)

	err = json.Unmarshal(data, &mf)
	if err != nil {
		return err
	}

	var rawMap map[string]json.RawMessage

	err = json.Unmarshal(data, &rawMap)
	if err != nil {
		rawMap = nil
	}

	for _, key := range knownKeysFooValue {
		delete(rawMap, key)
	}

	for key, rawValue := range rawMap {
		if mf.AdditionalProperties == nil {
			mf.AdditionalProperties = make(map[string]interface{}, 1)
		}

		var val interface{}

		err = json.Unmarshal(rawValue, &val)
		if err != nil {
			return err
		}

		mf.AdditionalProperties[key] = val
	}

	*f = FooValue(mf)

	return nil
}

// MarshalJSON encodes JSON.
func (f FooValue) MarshalJSON() ([]byte, error) {
	if len(f.AdditionalProperties) == 0 {
		return json.Marshal(marshalFooValue(f))
	}

	return marshalUnion(marshalFooValue(f), f.AdditionalProperties)
}

// UsecaseUpdateFooInput structure is generated from "#/components/schemas/UsecaseUpdateFooInput".
type UsecaseUpdateFooInput struct {
	ActivateSince        *time.Time                    `json:"activateSince,omitempty"`   // Format: date-time.
	ActivateTill         *time.Time                    `json:"activateTill,omitempty"`    // Format: date-time.
	// Acme Mille.
	// Value must match pattern: `^[a-zA-Z]{2}$`.
	// Required.
	Mille                string                        `json:"mille"`
	LocalActivation      map[string]FooLocalActivation `json:"localActivation,omitempty"`
	UselyKey             string                        `json:"uselyKey"`                  // Required.
	PotatoFamily         string                        `json:"potatoFamily"`              // Required.
	BarRules             *map[string]FooBarRule        `json:"barRules"`                  // Required.
	// Acme Look.
	// Value must match pattern: `^[0-9]{4}-W(0[1-9]|[1-4][0-9]|5[0-3])$`.
	// Required.
	LookEnd              string                        `json:"lookEnd"`
	// Acme Look.
	// Value must match pattern: `^[0-9]{4}-W(0[1-9]|[1-4][0-9]|5[0-3])$`.
	// Required.
	LookStart            string                        `json:"lookStart"`
	AdditionalProperties map[string]interface{}        `json:"-"`                         // All unmatched properties.
}

type marshalUsecaseUpdateFooInput UsecaseUpdateFooInput

var knownKeysUsecaseUpdateFooInput = []string{
	"activateSince",
	"activateTill",
	"mille",
	"localActivation",
	"uselyKey",
	"potatoFamily",
	"barRules",
	"lookEnd",
	"lookStart",
}

// UnmarshalJSON decodes JSON.
func (u *UsecaseUpdateFooInput) UnmarshalJSON(data []byte) error {
	var err error

	mu := marshalUsecaseUpdateFooInput(*u)

	err = json.Unmarshal(data, &mu)
	if err != nil {
		return err
	}

	var rawMap map[string]json.RawMessage

	err = json.Unmarshal(data, &rawMap)
	if err != nil {
		rawMap = nil
	}

	for _, key := range knownKeysUsecaseUpdateFooInput {
		delete(rawMap, key)
	}

	for key, rawValue := range rawMap {
		if mu.AdditionalProperties == nil {
			mu.AdditionalProperties = make(map[string]interface{}, 1)
		}

		var val interface{}

		err = json.Unmarshal(rawValue, &val)
		if err != nil {
			return err
		}

		mu.AdditionalProperties[key] = val
	}

	*u = UsecaseUpdateFooInput(mu)

	return nil
}

// MarshalJSON encodes JSON.
func (u UsecaseUpdateFooInput) MarshalJSON() ([]byte, error) {
	if len(u.AdditionalProperties) == 0 {
		return json.Marshal(marshalUsecaseUpdateFooInput(u))
	}

	return marshalUnion(marshalUsecaseUpdateFooInput(u), u.AdditionalProperties)
}

// UsecaseFindAvailableCarrotsInput structure is generated from "#/components/schemas/UsecaseFindAvailableCarrotsInput".
type UsecaseFindAvailableCarrotsInput struct {
	Items                map[string]UsecaseFindAvailableCarrotsInputItem `json:"items"` // Required.
	AdditionalProperties map[string]interface{}                          `json:"-"`     // All unmatched properties.
}

type marshalUsecaseFindAvailableCarrotsInput UsecaseFindAvailableCarrotsInput

var knownKeysUsecaseFindAvailableCarrotsInput = []string{
	"items",
}

// UnmarshalJSON decodes JSON.
func (u *UsecaseFindAvailableCarrotsInput) UnmarshalJSON(data []byte) error {
	var err error

	mu := marshalUsecaseFindAvailableCarrotsInput(*u)

	err = json.Unmarshal(data, &mu)
	if err != nil {
		return err
	}

	var rawMap map[string]json.RawMessage

	err = json.Unmarshal(data, &rawMap)
	if err != nil {
		rawMap = nil
	}

	for _, key := range knownKeysUsecaseFindAvailableCarrotsInput {
		delete(rawMap, key)
	}

	for key, rawValue := range rawMap {
		if mu.AdditionalProperties == nil {
			mu.AdditionalProperties = make(map[string]interface{}, 1)
		}

		var val interface{}

		err = json.Unmarshal(rawValue, &val)
		if err != nil {
			return err
		}

		mu.AdditionalProperties[key] = val
	}

	*u = UsecaseFindAvailableCarrotsInput(mu)

	return nil
}

// MarshalJSON encodes JSON.
func (u UsecaseFindAvailableCarrotsInput) MarshalJSON() ([]byte, error) {
	if len(u.AdditionalProperties) == 0 {
		return json.Marshal(marshalUsecaseFindAvailableCarrotsInput(u))
	}

	return marshalUnion(marshalUsecaseFindAvailableCarrotsInput(u), u.AdditionalProperties)
}

// UsecaseFindAvailableCarrotsInputItem structure is generated from "#/components/schemas/UsecaseFindAvailableCarrotsInputItem".
type UsecaseFindAvailableCarrotsInputItem struct {
	FoxID                int64                  `json:"foxId,omitempty"`
	FoxUuid              string                 `json:"foxUuid,omitempty"`      // Format: uuid.
	PotatoFamily         string                 `json:"potatoFamily,omitempty"`
	HoleID               int64                  `json:"holeId"`                 // Required.
	AdditionalProperties map[string]interface{} `json:"-"`                      // All unmatched properties.
}

type marshalUsecaseFindAvailableCarrotsInputItem UsecaseFindAvailableCarrotsInputItem

var knownKeysUsecaseFindAvailableCarrotsInputItem = []string{
	"foxId",
	"foxUuid",
	"potatoFamily",
	"holeId",
}

// UnmarshalJSON decodes JSON.
func (u *UsecaseFindAvailableCarrotsInputItem) UnmarshalJSON(data []byte) error {
	var err error

	mu := marshalUsecaseFindAvailableCarrotsInputItem(*u)

	err = json.Unmarshal(data, &mu)
	if err != nil {
		return err
	}

	var rawMap map[string]json.RawMessage

	err = json.Unmarshal(data, &rawMap)
	if err != nil {
		rawMap = nil
	}

	for _, key := range knownKeysUsecaseFindAvailableCarrotsInputItem {
		delete(rawMap, key)
	}

	for key, rawValue := range rawMap {
		if mu.AdditionalProperties == nil {
			mu.AdditionalProperties = make(map[string]interface{}, 1)
		}

		var val interface{}

		err = json.Unmarshal(rawValue, &val)
		if err != nil {
			return err
		}

		mu.AdditionalProperties[key] = val
	}

	*u = UsecaseFindAvailableCarrotsInputItem(mu)

	return nil
}

// MarshalJSON encodes JSON.
func (u UsecaseFindAvailableCarrotsInputItem) MarshalJSON() ([]byte, error) {
	if len(u.AdditionalProperties) == 0 {
		return json.Marshal(marshalUsecaseFindAvailableCarrotsInputItem(u))
	}

	return marshalUnion(marshalUsecaseFindAvailableCarrotsInputItem(u), u.AdditionalProperties)
}

// UsecaseFindAvailableCarrotsOutput structure is generated from "#/components/schemas/UsecaseFindAvailableCarrotsOutput".
type UsecaseFindAvailableCarrotsOutput struct {
	Items                map[string]UsecaseFindAvailableCarrotsOutputItem `json:"items,omitempty"` // Available carrot indexes mapped with same key as input items.
	AdditionalProperties map[string]interface{}                           `json:"-"`               // All unmatched properties.
}

type marshalUsecaseFindAvailableCarrotsOutput UsecaseFindAvailableCarrotsOutput

var knownKeysUsecaseFindAvailableCarrotsOutput = []string{
	"items",
}

// UnmarshalJSON decodes JSON.
func (u *UsecaseFindAvailableCarrotsOutput) UnmarshalJSON(data []byte) error {
	var err error

	mu := marshalUsecaseFindAvailableCarrotsOutput(*u)

	err = json.Unmarshal(data, &mu)
	if err != nil {
		return err
	}

	var rawMap map[string]json.RawMessage

	err = json.Unmarshal(data, &rawMap)
	if err != nil {
		rawMap = nil
	}

	for _, key := range knownKeysUsecaseFindAvailableCarrotsOutput {
		delete(rawMap, key)
	}

	for key, rawValue := range rawMap {
		if mu.AdditionalProperties == nil {
			mu.AdditionalProperties = make(map[string]interface{}, 1)
		}

		var val interface{}

		err = json.Unmarshal(rawValue, &val)
		if err != nil {
			return err
		}

		mu.AdditionalProperties[key] = val
	}

	*u = UsecaseFindAvailableCarrotsOutput(mu)

	return nil
}

// MarshalJSON encodes JSON.
func (u UsecaseFindAvailableCarrotsOutput) MarshalJSON() ([]byte, error) {
	if len(u.AdditionalProperties) == 0 {
		return json.Marshal(marshalUsecaseFindAvailableCarrotsOutput(u))
	}

	return marshalUnion(marshalUsecaseFindAvailableCarrotsOutput(u), u.AdditionalProperties)
}

// UsecaseFindAvailableCarrotsOutputItem structure is generated from "#/components/schemas/UsecaseFindAvailableCarrotsOutputItem".
type UsecaseFindAvailableCarrotsOutputItem struct {
	Carrots              []int64                `json:"carrots,omitempty"`
	Error                string                 `json:"error,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`                 // All unmatched properties.
}

type marshalUsecaseFindAvailableCarrotsOutputItem UsecaseFindAvailableCarrotsOutputItem

var knownKeysUsecaseFindAvailableCarrotsOutputItem = []string{
	"carrots",
	"error",
}

// UnmarshalJSON decodes JSON.
func (u *UsecaseFindAvailableCarrotsOutputItem) UnmarshalJSON(data []byte) error {
	var err error

	mu := marshalUsecaseFindAvailableCarrotsOutputItem(*u)

	err = json.Unmarshal(data, &mu)
	if err != nil {
		return err
	}

	var rawMap map[string]json.RawMessage

	err = json.Unmarshal(data, &rawMap)
	if err != nil {
		rawMap = nil
	}

	for _, key := range knownKeysUsecaseFindAvailableCarrotsOutputItem {
		delete(rawMap, key)
	}

	for key, rawValue := range rawMap {
		if mu.AdditionalProperties == nil {
			mu.AdditionalProperties = make(map[string]interface{}, 1)
		}

		var val interface{}

		err = json.Unmarshal(rawValue, &val)
		if err != nil {
			return err
		}

		mu.AdditionalProperties[key] = val
	}

	*u = UsecaseFindAvailableCarrotsOutputItem(mu)

	return nil
}

// MarshalJSON encodes JSON.
func (u UsecaseFindAvailableCarrotsOutputItem) MarshalJSON() ([]byte, error) {
	if len(u.AdditionalProperties) == 0 {
		return json.Marshal(marshalUsecaseFindAvailableCarrotsOutputItem(u))
	}

	return marshalUnion(marshalUsecaseFindAvailableCarrotsOutputItem(u), u.AdditionalProperties)
}

// LieAreaValue structure is generated from "#/components/schemas/LieAreaValue".
type LieAreaValue struct {
	// Acme Mille.
	// Value must match pattern: `^[a-zA-Z]{2}$`.
	// Required.
	Mille                string                 `json:"mille"`
	Name                 string                 `json:"name"`  // Required.
	Areas                *[]string              `json:"areas"` // Required.
	AdditionalProperties map[string]interface{} `json:"-"`     // All unmatched properties.
}

type marshalLieAreaValue LieAreaValue

var knownKeysLieAreaValue = []string{
	"mille",
	"name",
	"areas",
}

// UnmarshalJSON decodes JSON.
func (l *LieAreaValue) UnmarshalJSON(data []byte) error {
	var err error

	ml := marshalLieAreaValue(*l)

	err = json.Unmarshal(data, &ml)
	if err != nil {
		return err
	}

	var rawMap map[string]json.RawMessage

	err = json.Unmarshal(data, &rawMap)
	if err != nil {
		rawMap = nil
	}

	for _, key := range knownKeysLieAreaValue {
		delete(rawMap, key)
	}

	for key, rawValue := range rawMap {
		if ml.AdditionalProperties == nil {
			ml.AdditionalProperties = make(map[string]interface{}, 1)
		}

		var val interface{}

		err = json.Unmarshal(rawValue, &val)
		if err != nil {
			return err
		}

		ml.AdditionalProperties[key] = val
	}

	*l = LieAreaValue(ml)

	return nil
}

// MarshalJSON encodes JSON.
func (l LieAreaValue) MarshalJSON() ([]byte, error) {
	if len(l.AdditionalProperties) == 0 {
		return json.Marshal(marshalLieAreaValue(l))
	}

	return marshalUnion(marshalLieAreaValue(l), l.AdditionalProperties)
}

// LieAreaEntity structure is generated from "#/components/schemas/LieAreaEntity".
type LieAreaEntity struct {
	// Acme Mille.
	// Value must match pattern: `^[a-zA-Z]{2}$`.
	// Required.
	Mille                string                 `json:"mille"`
	CreatedAt            *time.Time             `json:"createdAt,omitempty"` // Format: date-time.
	ID                   int64                  `json:"id,omitempty"`
	Name                 string                 `json:"name"`                // Required.
	Areas                *[]string              `json:"areas"`               // Required.
	UpdatedAt            *time.Time             `json:"updatedAt,omitempty"` // Format: date-time.
	AdditionalProperties map[string]interface{} `json:"-"`                   // All unmatched properties.
}

type marshalLieAreaEntity LieAreaEntity

var knownKeysLieAreaEntity = []string{
	"mille",
	"createdAt",
	"id",
	"name",
	"areas",
	"updatedAt",
}

// UnmarshalJSON decodes JSON.
func (l *LieAreaEntity) UnmarshalJSON(data []byte) error {
	var err error

	ml := marshalLieAreaEntity(*l)

	err = json.Unmarshal(data, &ml)
	if err != nil {
		return err
	}

	var rawMap map[string]json.RawMessage

	err = json.Unmarshal(data, &rawMap)
	if err != nil {
		rawMap = nil
	}

	for _, key := range knownKeysLieAreaEntity {
		delete(rawMap, key)
	}

	for key, rawValue := range rawMap {
		if ml.AdditionalProperties == nil {
			ml.AdditionalProperties = make(map[string]interface{}, 1)
		}

		var val interface{}

		err = json.Unmarshal(rawValue, &val)
		if err != nil {
			return err
		}

		ml.AdditionalProperties[key] = val
	}

	*l = LieAreaEntity(ml)

	return nil
}

// MarshalJSON encodes JSON.
func (l LieAreaEntity) MarshalJSON() ([]byte, error) {
	if len(l.AdditionalProperties) == 0 {
		return json.Marshal(marshalLieAreaEntity(l))
	}

	return marshalUnion(marshalLieAreaEntity(l), l.AdditionalProperties)
}

// LiesPage structure is generated from "#/components/schemas/LiesPage".
type LiesPage struct {
	Count                int64                  `json:"count,omitempty"`
	Items                *[]LiesLie             `json:"items,omitempty"`
	Skip                 int64                  `json:"skip,omitempty"`
	Take                 int64                  `json:"take,omitempty"`
	Total                int64                  `json:"total,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`               // All unmatched properties.
}

type marshalLiesPage LiesPage

var knownKeysLiesPage = []string{
	"count",
	"items",
	"skip",
	"take",
	"total",
}

// UnmarshalJSON decodes JSON.
func (l *LiesPage) UnmarshalJSON(data []byte) error {
	var err error

	ml := marshalLiesPage(*l)

	err = json.Unmarshal(data, &ml)
	if err != nil {
		return err
	}

	var rawMap map[string]json.RawMessage

	err = json.Unmarshal(data, &rawMap)
	if err != nil {
		rawMap = nil
	}

	for _, key := range knownKeysLiesPage {
		delete(rawMap, key)
	}

	for key, rawValue := range rawMap {
		if ml.AdditionalProperties == nil {
			ml.AdditionalProperties = make(map[string]interface{}, 1)
		}

		var val interface{}

		err = json.Unmarshal(rawValue, &val)
		if err != nil {
			return err
		}

		ml.AdditionalProperties[key] = val
	}

	*l = LiesPage(ml)

	return nil
}

// MarshalJSON encodes JSON.
func (l LiesPage) MarshalJSON() ([]byte, error) {
	if len(l.AdditionalProperties) == 0 {
		return json.Marshal(marshalLiesPage(l))
	}

	return marshalUnion(marshalLiesPage(l), l.AdditionalProperties)
}

// LiesLie structure is generated from "#/components/schemas/LiesLie".
type LiesLie struct {
	AverageRating            float64                `json:"averageRating,omitempty"`
	ClonedFrom               *string                `json:"clonedFrom"`
	Mille                    string                 `json:"mille,omitempty"`
	Carrots                  *[]LiesCarrot          `json:"carrots,omitempty"`
	CreatedAt                string                 `json:"createdAt,omitempty"`
	Headline                 string                 `json:"headline,omitempty"`
	ID                       string                 `json:"id,omitempty"`
	IsActive                 *bool                  `json:"isActive"`
	IsComplete               *bool                  `json:"isComplete"`
	Link                     string                 `json:"link,omitempty"`
	MeatSwanCombinations     *[][]string            `json:"meatSwanCombinations,omitempty"`
	MeatSwanCombinationsText *string                `json:"meatSwanCombinationsText"`
	Modularity               *[]LiesModularity      `json:"modularity,omitempty"`
	Preferences              *[]LiesPreference      `json:"preferences,omitempty"`
	Potato                   string                 `json:"potato,omitempty"`
	Rated                    int64                  `json:"rated,omitempty"`
	SerializedPreferences    *string                `json:"serializedPreferences"`
	SurveyBody               *string                `json:"surveyBody"`
	SurveyOptIn              *string                `json:"surveyOptIn"`
	SurveyQuestion           *string                `json:"surveyQuestion"`
	SurveyTitle              *string                `json:"surveyTitle"`
	UpdatedAt                string                 `json:"updatedAt,omitempty"`
	Look                     string                 `json:"look,omitempty"`
	AdditionalProperties     map[string]interface{} `json:"-"`                              // All unmatched properties.
}

type marshalLiesLie LiesLie

var knownKeysLiesLie = []string{
	"averageRating",
	"clonedFrom",
	"mille",
	"carrots",
	"createdAt",
	"headline",
	"id",
	"isActive",
	"isComplete",
	"link",
	"meatSwanCombinations",
	"meatSwanCombinationsText",
	"modularity",
	"preferences",
	"potato",
	"rated",
	"serializedPreferences",
	"surveyBody",
	"surveyOptIn",
	"surveyQuestion",
	"surveyTitle",
	"updatedAt",
	"look",
}

// UnmarshalJSON decodes JSON.
func (l *LiesLie) UnmarshalJSON(data []byte) error {
	var err error

	ml := marshalLiesLie(*l)

	err = json.Unmarshal(data, &ml)
	if err != nil {
		return err
	}

	var rawMap map[string]json.RawMessage

	err = json.Unmarshal(data, &rawMap)
	if err != nil {
		rawMap = nil
	}

	for _, key := range knownKeysLiesLie {
		delete(rawMap, key)
	}

	for key, rawValue := range rawMap {
		if ml.AdditionalProperties == nil {
			ml.AdditionalProperties = make(map[string]interface{}, 1)
		}

		var val interface{}

		err = json.Unmarshal(rawValue, &val)
		if err != nil {
			return err
		}

		ml.AdditionalProperties[key] = val
	}

	*l = LiesLie(ml)

	return nil
}

// MarshalJSON encodes JSON.
func (l LiesLie) MarshalJSON() ([]byte, error) {
	if len(l.AdditionalProperties) == 0 {
		return json.Marshal(marshalLiesLie(l))
	}

	return marshalUnion(marshalLiesLie(l), l.AdditionalProperties)
}

// LiesCarrot structure is generated from "#/components/schemas/LiesCarrot".
type LiesCarrot struct {
	DrainSetting         *LiesDrainSetting      `json:"drainSetting,omitempty"`
	Index                int64                  `json:"index,omitempty"`
	IsSoldOut            bool                   `json:"isSoldOut,omitempty"`
	Presets              *[]string              `json:"presets,omitempty"`
	Soup                 *LiesSoup              `json:"soup,omitempty"`
	AreaTags             []string               `json:"areaTags,omitempty"`
	SelectionLimit       *int64                 `json:"selectionLimit"`
	AdditionalProperties map[string]interface{} `json:"-"`                      // All unmatched properties.
}

type marshalLiesCarrot LiesCarrot

var knownKeysLiesCarrot = []string{
	"drainSetting",
	"index",
	"isSoldOut",
	"presets",
	"soup",
	"areaTags",
	"selectionLimit",
}

// UnmarshalJSON decodes JSON.
func (l *LiesCarrot) UnmarshalJSON(data []byte) error {
	var err error

	ml := marshalLiesCarrot(*l)

	err = json.Unmarshal(data, &ml)
	if err != nil {
		return err
	}

	var rawMap map[string]json.RawMessage

	err = json.Unmarshal(data, &rawMap)
	if err != nil {
		rawMap = nil
	}

	for _, key := range knownKeysLiesCarrot {
		delete(rawMap, key)
	}

	for key, rawValue := range rawMap {
		if ml.AdditionalProperties == nil {
			ml.AdditionalProperties = make(map[string]interface{}, 1)
		}

		var val interface{}

		err = json.Unmarshal(rawValue, &val)
		if err != nil {
			return err
		}

		ml.AdditionalProperties[key] = val
	}

	*l = LiesCarrot(ml)

	return nil
}

// MarshalJSON encodes JSON.
func (l LiesCarrot) MarshalJSON() ([]byte, error) {
	if len(l.AdditionalProperties) == 0 {
		return json.Marshal(marshalLiesCarrot(l))
	}

	return marshalUnion(marshalLiesCarrot(l), l.AdditionalProperties)
}

// LiesDrainSetting structure is generated from "#/components/schemas/LiesDrainSetting".
type LiesDrainSetting struct {
	Amount               *int64                 `json:"amount"`
	RigidAmounts         *[]LiesRigidAmount     `json:"rigidAmounts,omitempty"`
	RigidQuantities      *[]LiesRigidQuantity   `json:"rigidQuantities,omitempty"`
	Reason               string                 `json:"reason,omitempty"`
	Servings             *int64                 `json:"servings"`
	Strategy             string                 `json:"strategy,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`                         // All unmatched properties.
}

type marshalLiesDrainSetting LiesDrainSetting

var knownKeysLiesDrainSetting = []string{
	"amount",
	"rigidAmounts",
	"rigidQuantities",
	"reason",
	"servings",
	"strategy",
}

// UnmarshalJSON decodes JSON.
func (l *LiesDrainSetting) UnmarshalJSON(data []byte) error {
	var err error

	ml := marshalLiesDrainSetting(*l)

	err = json.Unmarshal(data, &ml)
	if err != nil {
		return err
	}

	var rawMap map[string]json.RawMessage

	err = json.Unmarshal(data, &rawMap)
	if err != nil {
		rawMap = nil
	}

	for _, key := range knownKeysLiesDrainSetting {
		delete(rawMap, key)
	}

	for key, rawValue := range rawMap {
		if ml.AdditionalProperties == nil {
			ml.AdditionalProperties = make(map[string]interface{}, 1)
		}

		var val interface{}

		err = json.Unmarshal(rawValue, &val)
		if err != nil {
			return err
		}

		ml.AdditionalProperties[key] = val
	}

	*l = LiesDrainSetting(ml)

	return nil
}

// MarshalJSON encodes JSON.
func (l LiesDrainSetting) MarshalJSON() ([]byte, error) {
	if len(l.AdditionalProperties) == 0 {
		return json.Marshal(marshalLiesDrainSetting(l))
	}

	return marshalUnion(marshalLiesDrainSetting(l), l.AdditionalProperties)
}

// LiesRigidAmount structure is generated from "#/components/schemas/LiesRigidAmount".
type LiesRigidAmount struct {
	Amount               int64                  `json:"amount,omitempty"`
	People               int64                  `json:"people,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`                // All unmatched properties.
}

type marshalLiesRigidAmount LiesRigidAmount

var knownKeysLiesRigidAmount = []string{
	"amount",
	"people",
}

// UnmarshalJSON decodes JSON.
func (l *LiesRigidAmount) UnmarshalJSON(data []byte) error {
	var err error

	ml := marshalLiesRigidAmount(*l)

	err = json.Unmarshal(data, &ml)
	if err != nil {
		return err
	}

	var rawMap map[string]json.RawMessage

	err = json.Unmarshal(data, &rawMap)
	if err != nil {
		rawMap = nil
	}

	for _, key := range knownKeysLiesRigidAmount {
		delete(rawMap, key)
	}

	for key, rawValue := range rawMap {
		if ml.AdditionalProperties == nil {
			ml.AdditionalProperties = make(map[string]interface{}, 1)
		}

		var val interface{}

		err = json.Unmarshal(rawValue, &val)
		if err != nil {
			return err
		}

		ml.AdditionalProperties[key] = val
	}

	*l = LiesRigidAmount(ml)

	return nil
}

// MarshalJSON encodes JSON.
func (l LiesRigidAmount) MarshalJSON() ([]byte, error) {
	if len(l.AdditionalProperties) == 0 {
		return json.Marshal(marshalLiesRigidAmount(l))
	}

	return marshalUnion(marshalLiesRigidAmount(l), l.AdditionalProperties)
}

// LiesRigidQuantity structure is generated from "#/components/schemas/LiesRigidQuantity".
type LiesRigidQuantity struct {
	Amount               int64                  `json:"amount,omitempty"`
	People               int64                  `json:"people,omitempty"`
	Quantity             int64                  `json:"quantity,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`                  // All unmatched properties.
}

type marshalLiesRigidQuantity LiesRigidQuantity

var knownKeysLiesRigidQuantity = []string{
	"amount",
	"people",
	"quantity",
}

// UnmarshalJSON decodes JSON.
func (l *LiesRigidQuantity) UnmarshalJSON(data []byte) error {
	var err error

	ml := marshalLiesRigidQuantity(*l)

	err = json.Unmarshal(data, &ml)
	if err != nil {
		return err
	}

	var rawMap map[string]json.RawMessage

	err = json.Unmarshal(data, &rawMap)
	if err != nil {
		rawMap = nil
	}

	for _, key := range knownKeysLiesRigidQuantity {
		delete(rawMap, key)
	}

	for key, rawValue := range rawMap {
		if ml.AdditionalProperties == nil {
			ml.AdditionalProperties = make(map[string]interface{}, 1)
		}

		var val interface{}

		err = json.Unmarshal(rawValue, &val)
		if err != nil {
			return err
		}

		ml.AdditionalProperties[key] = val
	}

	*l = LiesRigidQuantity(ml)

	return nil
}

// MarshalJSON encodes JSON.
func (l LiesRigidQuantity) MarshalJSON() ([]byte, error) {
	if len(l.AdditionalProperties) == 0 {
		return json.Marshal(marshalLiesRigidQuantity(l))
	}

	return marshalUnion(marshalLiesRigidQuantity(l), l.AdditionalProperties)
}

// LiesSoup structure is generated from "#/components/schemas/LiesSoup".
type LiesSoup struct {
	Active               *bool                     `json:"active"`
	Allergens            *[]map[string]interface{} `json:"allergens,omitempty"`
	Mille                string                    `json:"mille,omitempty"`
	ID                   string                    `json:"id,omitempty"`
	Ingredients          *[]LiesSoupIngredient     `json:"ingredients,omitempty"`
	Name                 string                    `json:"name,omitempty"`
	Slug                 string                    `json:"slug,omitempty"`
	AdditionalProperties map[string]interface{}    `json:"-"`                     // All unmatched properties.
}

type marshalLiesSoup LiesSoup

var knownKeysLiesSoup = []string{
	"active",
	"allergens",
	"mille",
	"id",
	"ingredients",
	"name",
	"slug",
}

// UnmarshalJSON decodes JSON.
func (l *LiesSoup) UnmarshalJSON(data []byte) error {
	var err error

	ml := marshalLiesSoup(*l)

	err = json.Unmarshal(data, &ml)
	if err != nil {
		return err
	}

	var rawMap map[string]json.RawMessage

	err = json.Unmarshal(data, &rawMap)
	if err != nil {
		rawMap = nil
	}

	for _, key := range knownKeysLiesSoup {
		delete(rawMap, key)
	}

	for key, rawValue := range rawMap {
		if ml.AdditionalProperties == nil {
			ml.AdditionalProperties = make(map[string]interface{}, 1)
		}

		var val interface{}

		err = json.Unmarshal(rawValue, &val)
		if err != nil {
			return err
		}

		ml.AdditionalProperties[key] = val
	}

	*l = LiesSoup(ml)

	return nil
}

// MarshalJSON encodes JSON.
func (l LiesSoup) MarshalJSON() ([]byte, error) {
	if len(l.AdditionalProperties) == 0 {
		return json.Marshal(marshalLiesSoup(l))
	}

	return marshalUnion(marshalLiesSoup(l), l.AdditionalProperties)
}

// LiesSoupIngredient structure is generated from "#/components/schemas/LiesSoupIngredient".
type LiesSoupIngredient struct {
	Allergens            *[]map[string]interface{} `json:"allergens,omitempty"`
	Mille                string                    `json:"mille,omitempty"`
	Description          *string                   `json:"description"`
	Family               *LiesSoupIngredientFamily `json:"family,omitempty"`
	HasDuplicatedName    *bool                     `json:"hasDuplicatedName"`
	ID                   string                    `json:"id,omitempty"`
	ImageLink            *string                   `json:"imageLink"`
	ImagePath            *string                   `json:"imagePath"`
	InternalName         *string                   `json:"internalName"`
	Name                 string                    `json:"name,omitempty"`
	Shipped              *bool                     `json:"shipped"`
	Slug                 string                    `json:"slug,omitempty"`
	Type                 string                    `json:"type,omitempty"`
	Usage                int64                     `json:"usage,omitempty"`
	AdditionalProperties map[string]interface{}    `json:"-"`                   // All unmatched properties.
}

type marshalLiesSoupIngredient LiesSoupIngredient

var knownKeysLiesSoupIngredient = []string{
	"allergens",
	"mille",
	"description",
	"family",
	"hasDuplicatedName",
	"id",
	"imageLink",
	"imagePath",
	"internalName",
	"name",
	"shipped",
	"slug",
	"type",
	"usage",
}

// UnmarshalJSON decodes JSON.
func (l *LiesSoupIngredient) UnmarshalJSON(data []byte) error {
	var err error

	ml := marshalLiesSoupIngredient(*l)

	err = json.Unmarshal(data, &ml)
	if err != nil {
		return err
	}

	var rawMap map[string]json.RawMessage

	err = json.Unmarshal(data, &rawMap)
	if err != nil {
		rawMap = nil
	}

	for _, key := range knownKeysLiesSoupIngredient {
		delete(rawMap, key)
	}

	for key, rawValue := range rawMap {
		if ml.AdditionalProperties == nil {
			ml.AdditionalProperties = make(map[string]interface{}, 1)
		}

		var val interface{}

		err = json.Unmarshal(rawValue, &val)
		if err != nil {
			return err
		}

		ml.AdditionalProperties[key] = val
	}

	*l = LiesSoupIngredient(ml)

	return nil
}

// MarshalJSON encodes JSON.
func (l LiesSoupIngredient) MarshalJSON() ([]byte, error) {
	if len(l.AdditionalProperties) == 0 {
		return json.Marshal(marshalLiesSoupIngredient(l))
	}

	return marshalUnion(marshalLiesSoupIngredient(l), l.AdditionalProperties)
}

// LiesSoupIngredientFamily structure is generated from "#/components/schemas/LiesSoupIngredientFamily".
type LiesSoupIngredientFamily struct {
	CreatedAt            string                 `json:"createdAt,omitempty"`
	Description          *string                `json:"description"`
	IconLink             *string                `json:"iconLink"`
	IconPath             *string                `json:"iconPath"`
	ID                   string                 `json:"id,omitempty"`
	Name                 string                 `json:"name,omitempty"`
	Priority             int64                  `json:"priority,omitempty"`
	Slug                 string                 `json:"slug,omitempty"`
	Type                 string                 `json:"type,omitempty"`
	UpdatedAt            string                 `json:"updatedAt,omitempty"`
	UsageByMille         *map[string]int64      `json:"usageByMille,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`                      // All unmatched properties.
}

type marshalLiesSoupIngredientFamily LiesSoupIngredientFamily

var knownKeysLiesSoupIngredientFamily = []string{
	"createdAt",
	"description",
	"iconLink",
	"iconPath",
	"id",
	"name",
	"priority",
	"slug",
	"type",
	"updatedAt",
	"usageByMille",
}

// UnmarshalJSON decodes JSON.
func (l *LiesSoupIngredientFamily) UnmarshalJSON(data []byte) error {
	var err error

	ml := marshalLiesSoupIngredientFamily(*l)

	err = json.Unmarshal(data, &ml)
	if err != nil {
		return err
	}

	var rawMap map[string]json.RawMessage

	err = json.Unmarshal(data, &rawMap)
	if err != nil {
		rawMap = nil
	}

	for _, key := range knownKeysLiesSoupIngredientFamily {
		delete(rawMap, key)
	}

	for key, rawValue := range rawMap {
		if ml.AdditionalProperties == nil {
			ml.AdditionalProperties = make(map[string]interface{}, 1)
		}

		var val interface{}

		err = json.Unmarshal(rawValue, &val)
		if err != nil {
			return err
		}

		ml.AdditionalProperties[key] = val
	}

	*l = LiesSoupIngredientFamily(ml)

	return nil
}

// MarshalJSON encodes JSON.
func (l LiesSoupIngredientFamily) MarshalJSON() ([]byte, error) {
	if len(l.AdditionalProperties) == 0 {
		return json.Marshal(marshalLiesSoupIngredientFamily(l))
	}

	return marshalUnion(marshalLiesSoupIngredientFamily(l), l.AdditionalProperties)
}

func marshalUnion(maps ...interface{}) ([]byte, error) {
	result := []byte("{")
	isObject := true

	for _, m := range maps {
		j, err := json.Marshal(m)
		if err != nil {
			return nil, err
		}

		if string(j) == "{}" {
			continue
		}

		if string(j) == "null" {
			continue
		}

		if j[0] != '{' {
			if len(result) == 1 && (isObject || bytes.Equal(result, j)) {
				result = j
				isObject = false

				continue
			}

			return nil, errors.New("failed to union map: object expected, " + string(j) + " received")
		}

		if !isObject {
			return nil, errors.New("failed to union " + string(result) + " and " + string(j))
		}

		if len(result) > 1 {
			result[len(result)-1] = ','
		}

		result = append(result, j[1:]...)
	}

	// Close empty result.
	if isObject && len(result) == 1 {
		result = append(result, '}')
	}

	return result, nil
}
