<?php

namespace Swac\JavaScript\Client;

use Swac\Command\App;
use Swac\OpenAPI3\Reader;
use Swac\Rest\Config;
use Swac\Rest\Operation;
use Swac\Rest\Parameter;
use Swac\Rest\Renderer;
use Swac\Rest\Response;
use Swaggest\CodeBuilder\AbstractTemplate;
use Swaggest\GoCodeBuilder\Templates\Code;
use Swaggest\JsonSchema\Schema;
use Swaggest\PhpCodeBuilder\JSDoc\TypeBuilder;
use Swaggest\PhpCodeBuilder\PhpCode;
use Swaggest\SwaggerHttp\StatusCodes;

class Client extends AbstractTemplate implements Renderer
{
    const PARAM_FIELD_NAME_META = 'jsDocFieldName';
    const RAW_CALLBACK = 'RawCallback';

    /**
     * @var TypeBuilder
     */
    public $jsDocTypes;

    /** @var string[] */
    private $operationNames;

    /** @var string */
    public $clientName = 'APIClient';

    /** @var string[] */
    private $responseCallbacks = [];

    /** @var Code */
    private $clientFile;

    /** @var Code */
    private $clientCode;

    public function __construct()
    {
        $ver = App::$ver;

        $this->jsDocTypes = new TypeBuilder();
        $this->jsDocTypes->trimNamePrefix[] = '#/components/schemas';

        $head = <<<JS
// Code is generated by github.com/swaggest/swac $ver, DO NOT EDIT. ðŸ¤–


JS;

        $this->jsDocTypes->file .= $head;
        $this->clientCode = new Code();
        $this->clientFile = new Code();

        $this->clientFile->addSnippet($head);
    }

    public function setConfig(Config $config)
    {
        $headComment = '';
        if (!empty(trim($config->title))) {
            $headComment .= trim($config->title) . "\n";
        }
        if (!empty(trim($config->version))) {
            $headComment .= 'Version: ' . trim($config->version) . "\n";
        }
        if (!empty(trim($config->description))) {
            $headComment .= trim(wordwrap($config->description)) . "\n";
        }


        $this->clientCode->addSnippet(<<<JS
/**
{$this->padLines(' * ', $headComment, false)} * @constructor
 * @param {string} baseURL - Base URL.
 */
function {$this->clientName}(baseURL) {
    // Trim trailing backslash.
    this.baseURL = (baseURL.charAt(baseURL.length - 1) === '/') ? baseURL.slice(0, -1) : baseURL;
    /** @type {?PrepareRequest} - Callback to prepare request before sending. */
    this.prepareRequest = null;
}

/**
 * @callback PrepareRequest
 * @param {XMLHttpRequest} value
 */


JS
        );
    }

    public function addOperation(Operation $operation)
    {
        $funcName = '';
        if ($operation->operationId !== null) {
            $funcName = $this->makeName($operation->operationId);
        }

        if (empty($funcName) || isset($this->operationNames)) {
            $funcName = $this->makeName($operation->method . '_' . $operation->path);
        }

        $this->operationNames[$funcName] = true;

        $this->makeOperationFunction($operation, $funcName);
    }

    /**
     * @param Parameter[] $parameters
     * @param string $pattern
     * @return string
     */
    private function makeURL($parameters, $pattern)
    {
        $res = "var url = this.baseURL + '$pattern?';\n";
        if (!empty($parameters)) {
            foreach ($parameters as $parameter) {
                $field = $parameter->meta[self::PARAM_FIELD_NAME_META];

                $encodedValue = "encodeURIComponent(req.$field)";
                if ($parameter->isJson) {
                    $encodedValue = "encodeURIComponent(JSON.stringify(req.$field))";
                }

                if ($parameter->in === Parameter::PATH) {
                    $res = str_replace("{{$parameter->name}}", "' + {$encodedValue} +\n'", $res);
                }

                if ($parameter->in === Parameter::QUERY) {
                    $res .= <<<JS
if (req.$field != null) {
    url += '{$parameter->name}=' + {$encodedValue} + '&';
}

JS;
                }
            }
        }

        $res .= "url = url.slice(0, -1);\n";

        return $res;
    }

    /**
     * @param Parameter[] $parameters
     * @return string
     */
    private function makeRequestHeaders($parameters)
    {
        if (empty($parameters)) {
            return '';
        }

        $res = '';

        foreach ($parameters as $parameter) {
            if ($parameter->in === Parameter::HEADER) {
                $field = $parameter->meta[self::PARAM_FIELD_NAME_META];
                $res .= <<<JS
if (typeof req.$field !== 'undefined') {
    x.setRequestHeader('{$parameter->name}', req.$field);
}

JS;
            }
        }

        return $res;
    }

    /**
     * @param Parameter[] $parameters
     * @return string
     */
    private function makeRequestJSONBody($parameters)
    {
        if (empty($parameters)) {
            return '';
        }

        foreach ($parameters as $parameter) {
            if ($parameter->in === Parameter::BODY) {
                $field = $parameter->meta[self::PARAM_FIELD_NAME_META];
                return <<<JS
if (typeof req.$field !== 'undefined') {
    x.setRequestHeader("Content-Type", "application/json; charset=utf-8");
    x.send(JSON.stringify(req.$field));
    return;
}

JS;
            }
        }

        return '';
    }

    /**
     * @param Schema $schema
     * @param string $type
     */
    private function hasType($schema, $type)
    {
        if ($schema === null || $schema->type === null) {
            return false;
        }

        if (is_array($schema->type)) {
            return in_array($type, $schema->type);
        }

        return $schema->type === $type;
    }

    /**
     * @param Parameter[] $parameters
     * @param string $contentType
     * @param string $body
     * @return string
     */
    private function makeRequestFormData($parameters, $contentType, &$body)
    {
        if (empty($parameters)) {
            return '';
        }

        $res = '';

        if ($contentType === Reader::APPLICATION_X_WWW_FORM_URLENCODED) {
            foreach ($parameters as $parameter) {
                if ($parameter->in === Parameter::FORM_DATA) {
                    $field = $parameter->meta[self::PARAM_FIELD_NAME_META];
                    $res .= <<<JS
if (typeof req.$field !== 'undefined') {
    formData += '{$parameter->name}=' + encodeURIComponent(req.$field) + '&'
}

JS;
                }
            }

            if ($res != '') {
                $res = <<<JS
var formData = ''
$res
if (formData !== '') {
    x.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
    x.send(formData.slice(0, -1))
    return  
}

JS;
            }
        } else {
            foreach ($parameters as $parameter) {
                if ($parameter->in === Parameter::FORM_DATA) {
                    $field = $parameter->meta[self::PARAM_FIELD_NAME_META];

                    if ($this->hasType($parameter->schema, Schema::_ARRAY)) {
                        $res .= <<<JS
if (typeof req.{$field} !== 'undefined') {
    for (var i = 0; i < req.{$field}.length; i++) {
        formData.append('profile', req.{$field}[i]);
    }
}

JS;
                    } else {
                        $res .= <<<JS
if (typeof req.$field !== 'undefined') {
    formData.append('{$parameter->name}', req.$field);
}

JS;
                    }
                }

            }

            if ($res != '') {
                $body = 'formData';
                $res = <<<JS
var formData = new FormData();
$res

JS;
            }
        }

        return $res;
    }

    /**
     * @param Operation $o
     * @param string $funcName
     */
    private function makeOperationFunction($o, $funcName)
    {
        $reqType = $this->makeRequestType($o->parameters, $funcName);
        $args = ['req'];

        $responseArguments = new Code();
        $responseSwitch = new Code();
        $hasDefault = false;
        foreach ($o->responses as $response) {
            $cbType = $this->makeResponseType($response);
            $responseArg = 'JSON.parse(x.responseText)';
            if ($cbType === self::RAW_CALLBACK) {
                $responseArg = 'x';
            }

            if ($response->isDefault) {
                $cbName = 'onDefault';
                $responseArguments->addSnippet(<<<JSDOC
 * @param {{$cbType}} {$cbName}

JSDOC
                );
                $args[] = $cbName;

                $responseSwitch->addSnippet(<<<CODE
            default:
                if (typeof({$cbName}) === 'function') {
                    {$cbName}($responseArg);
                }
                break;

CODE
                );

                $hasDefault = true;
                continue;
            }

            $status = StatusCodes::getInfoByCode($response->statusCode);
            $cbName = 'on' . $this->makeName($status->phrase, false);

            $responseArguments->addSnippet(<<<JSDOC
 * @param {{$cbType}} {$cbName}

JSDOC
            );

            $args[] = $cbName;
            $responseSwitch->addSnippet(<<<CODE
            case {$response->statusCode}:
                if (typeof({$cbName}) === 'function') {
                    {$cbName}($responseArg);
                }
                break;

CODE
            );
        }

        if (!$hasDefault) {
            $responseSwitch->addSnippet(<<<CODE
            default:
                throw {err: 'unexpected response', data: x};

CODE
            );
        }

        $args = join(', ', $args);
        $method = strtoupper($o->method);

        $headComment = '';
        if (!empty(trim($o->summary))) {
            $headComment .= trim($o->summary) . "\n";
        }
        if (!empty(trim($o->description))) {
            $headComment .= trim(wordwrap($o->description)) . "\n";
        }


        $body = '';
        $code = <<<JS
/**
{$this->padLines(' * ', $headComment, false)} * @param {{$reqType}} req - request parameters.
{$responseArguments} */
{$this->clientName}.prototype.{$funcName} = function ($args) {
    var x = new XMLHttpRequest();
    x.onreadystatechange = function () {
        if (x.readyState !== XMLHttpRequest.DONE) {
            return;
        }
    
        switch (x.status) {
{$responseSwitch}        }
    };
    
    {$this->padLines('    ', $this->makeURL($o->parameters, $o->path))}
    x.open("{$method}", url, true);
    if (typeof(this.prepareRequest) === 'function') {
        this.prepareRequest(x);
    }
    {$this->padLines('    ',
            $this->makeRequestHeaders($o->parameters) .
            $this->makeRequestJSONBody($o->parameters) .
            $this->makeRequestFormData($o->parameters, $o->contentType, $body))}
    x.send({$body});
};


JS;

        $this->clientCode->addSnippet($code);

    }


    /**
     * @param Response $response
     * @return string|null
     */
    private function makeResponseType($response)
    {
        if ($response->schema === null || $response->schema->format === 'binary') {
            $type = '___raw';
            $cbType = self::RAW_CALLBACK;
            if (!isset($this->responseCallbacks[$type])) {
                $cb = <<<JSDOC
/**
 * @callback {$cbType}
 * @param {XMLHttpRequest} value
 */


JSDOC;
                $this->jsDocTypes->file .= $cb;
                $this->responseCallbacks[$type] = $cbType;
            }

            return $cbType;
        }

        $type = $this->jsDocTypes->getTypeString($response->schema);
        $cbType = $this->makeName($type . '_callback', false);
        if (!isset($this->responseCallbacks[$type])) {
            $cb = <<<JSDOC
/**
 * @callback {$cbType}
 * @param {{$type}} value
 */


JSDOC;
            $this->jsDocTypes->file .= $cb;
            $this->responseCallbacks[$type] = $cbType;
        }

        return $cbType;
    }

    /**
     * @param Parameter[] $parameters
     * @param string $funcName
     * @return string
     */
    private function makeRequestType($parameters, $funcName)
    {
        $reqSchema = new Schema();
        $reqSchema->type = Schema::OBJECT;
        $reqSchema->setFromRef($funcName . '/Request');

        $paramNames = [];

        if (!empty($parameters)) {
            foreach ($parameters as $parameter) {
                $name = $this->makeName($parameter->name);
                if (isset($paramNames[$name])) {
                    $name = $this->makeName($parameter->name . '_' . $parameter->in);
                }

                $paramNames[$name] = true;
                $parameter->meta[self::PARAM_FIELD_NAME_META] = $name;

                if (!empty($parameter->description) && empty($parameter->schema->description)) {
                    $parameter->schema->description = $parameter->description;
                }

                $reqSchema->setProperty($name, $parameter->schema);
            }
        }

        return $this->jsDocTypes->getTypeString($reqSchema);
    }

    private function makeName($s, $lowerFirst = true)
    {
        return PhpCode::makePhpName($s, $lowerFirst);
    }

    public function store($path)
    {
        $this->clientFile->addSnippet(<<<JS
(function(){
    "use strict";
    
    {$this->padLines('    ', $this->clientCode->render())}
    
    window.{$this->clientName} = {$this->clientName};
})();
JS
);

        $this->jsDocTypes->file = preg_replace("/[\r\n]{2,}/", "\n\n", $this->jsDocTypes->file);
        $clientFile = preg_replace("/[\r\n]{2,}/", "\n\n", $this->clientFile->render());

        file_put_contents($path . '/jsdoc.js', $this->jsDocTypes->file);
        file_put_contents($path . '/client.js', $clientFile);
    }

    protected function toString()
    {
    }
}